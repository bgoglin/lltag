#!/usr/bin/perl -w

use strict ;
no strict "refs" ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

#######################################################
# configuration file location
my $common_lltag_dir = "@SYSCONFDIR@/lltag" ;
my $user_lltag_dir = "$ENV{HOME}/.lltag" ;
my $lltag_format_filename = "formats" ;

#######################################################
# format parameters
# (%a = artist, %t = title, %A = album, %n = number, %g = genre, %y = year)
my @field_name = ('artist', 'title', 'album', 'number', 'genre', 'year') ;
my @field_trailing_spaces = ('', ' ', ' ', '', ' ', '  ') ;
my @field_letter = ('a', 't', 'A', 'n', 'g', 'y') ;
my @field_mp3info_option = ('a', 't', 'l', 'n', 'g', 'y') ;
my @field_vorbiscomment_option = ('ARTIST', 'TITLE', 'ALBUM', 'TRACKNUMBER', 'GENRE', 'DATE') ;
my @field_default = (undef, undef, undef, undef, undef, undef) ;
my $fields = $#field_name + 1 ;

#######################################################
# version
my $version = "@VERSION@" ;

sub version() {
    print "This is lltag version $version.\n" ;
    exit 0 ;
}

#######################################################
# usage
sub usage() {
    print $0." $version is a frontend to tag MP3/OGG files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print "   Available options are:\n" ;
    print "     -F, --format <format>  Try format\n" ;
    print "     -G, --guess            Guess format\n" ;
    print "     -R, --recursive        Recursively search all files in subdirectories\n" ;
    print "     -p, --nopath           Remove the path from filenames when matching\n" ;
    print map { "     -".$field_letter[$_].", --".$field_name[$_].$field_trailing_spaces[$_]
		    ." <val>     Set the default value for "
		    .ucfirst($field_name[$_])."\n" } ( 0 .. $fields-1 ) ;
    print "     --spaces               Allow no or multiple spaces\n" ;
    print "     --sep <s1|s2|...>      Replace |-separated strings with space in tags\n" ;
    print "     --yes                  Tag without asking for confirmation when guessing\n" ;
    print "     --ask                  Always ask for confirmation before tagging\n" ;
    print "     --mp3/--ogg            Force mp3 or ogg instead of by-extension detection\n" ;
    print "     --dry-run              Do nothing but show what would have been done\n" ;
    print "     -L, --list             List internal formats\n" ;
    print "     -V, --version          Show lltag version\n" ;
    print "     -v, --verbose          Verbose messages\n" ;
    print "     -h, --help             Show this help\n" ;
    print "   Format is composed of anything you want with special fields:\n" ;
    print map { "     %".$field_letter[$_]." means ".ucfirst($field_name[$_])."\n" } ( 0 .. $fields-1 ) ;
    print "     %d means Dummy text\n" ;
    print "     %% means %\n" ;
    print "\n" ;
    print "Author:    Brice Goglin <Brice.Goglin\@ens-lyon.org>\n" ;
    print "Homepage:  http://bgoglin.free.fr/lltag\n" ;
    exit 1;
}

#######################################################
# cmdline options
my $ask_opt = 0 ;
my $dryrun_opt = 0 ;
my $guess_opt = 0 ;
my $nopath_opt = 0 ;
my $sep_opt = undef ;
my $spaces_opt = 0 ;
my $type_opt = undef ;
my $verbose_opt = 0 ;
my $yes_opt = 0 ;
my $recursive_opt = 0 ;
my $list_formats_opt = 0 ;
my $default_opt = 0 ;

my $ogg_type = "ogg" ;
my $mp3_type = "mp3" ;

# subregexp
my $match_path = '(?:[^/]*\/)*' ;
my $match_any = '((?:[^ /]+ +)*[^ /]+)' ;
my $match_num = '([0-9]+)' ;
my $match_space = ' ';
my $match_spaces = ' *' ;
my $match_limit = '' ;

# the parser that the user wants to always use
my $preferred_parser = undef ;

# parsers
my @format_strings = () ;

# parse options
GetOptions(
	   'F|format=s'   => \@format_strings,
	   'G|guess'      => \$guess_opt,
	   'R|recursive'  => \$recursive_opt,
	   'p|nopath'     => \$nopath_opt,
	   'spaces'       => \$spaces_opt,
	   'sep=s'        => \$sep_opt,
	   'yes'          => sub { $yes_opt = 1 ; $ask_opt = 0 ; },
	   'ask'          => sub { $ask_opt = 1 ; $yes_opt = 0 ; },
	   'mp3'          => sub { $type_opt = $mp3_type ; },
	   'ogg'          => sub { $type_opt = $ogg_type ; },
	   'dry-run'      => \$dryrun_opt,
	   'v|verbose'    => \$verbose_opt,
	   'h|help'       => sub { usage () ; },
	   'V|version'    => sub { version () ; },
	   'L|list'       => \$list_formats_opt,
	   map { my $i = $_; $field_letter[$i].'|'.$field_name[$i].'=s'
		=> sub { shift ; $field_default[$i] = shift ; $default_opt = 1 ; },
	  	} ( 0 .. $fields-1 )
	   ) or usage () ;

# yes/ask option status may vary with user confirmation replies
my $current_yes_opt = $yes_opt ;
my $current_ask_opt = $ask_opt ;

# spaces_opt changes matching regexps
$match_limit = $match_space = $match_spaces if $spaces_opt ;

# if no parsers and no guess
die "No format to try\n" unless @format_strings or $guess_opt or $default_opt or $list_formats_opt;
# TOFIX: show tags instead of tagging ? add an option to show tags ?

#######################################################
# Tagging return values
my $TAG_SUCCESS = 0 ;
my $TAG_SKIP_FILE = -1 ;
my $TAG_SKIP_PARSER = -2 ;
my $TAG_SKIP_PATH_PARSER = -3 ;
my $TAG_SUCCESS_PREFERED = 1 ;

#######################################################
# Tagging acceptable behavior
my $TAG_MAY_SKIP_PARSER = 1 ;
my $TAG_MAY_SKIP_PATH_PARSER = 2 ;
my $TAG_MAY_PREFER = 4 ;

#######################################################
# internal parsers

my @internal_filename_parsers = () ;
my @internal_path_parsers = () ;

if ($guess_opt or $list_formats_opt) {
    # get parsers from configuration files
    my @format_files = () ;
    push (@format_files, "$common_lltag_dir/$lltag_format_filename") ;
    push (@format_files, "$user_lltag_dir/$lltag_format_filename") ;
    foreach my $file (@format_files) {
	open FORMAT, $file or next ;
	print "Reading format files '$file'...\n" if $verbose_opt ;
	my $type = undef ;
	my $title = undef ;
	my $regexp = undef ;
	my @indice_table = () ;
	while (<FORMAT>) {
	    chomp $_ ;
	    next if /^#/ ;
	    next if /^$/ ;
	    if (/^\[(.*)\]$/) {
		if ($type and $title and $regexp and @indice_table) {
		    my $parser ;
		    $parser->{title} = $title ;
		    $parser->{regexp} = $regexp ;
		    $parser->{indices} = @indice_table ;
		    for(my $i = 0; $i < @indice_table; $i++) {
			$parser->{$i} = $indice_table[$i] ;
		    }
		    if ($type eq "filename") {
			print "  Got filename format '$title'\n" if $verbose_opt ;
			push (@internal_filename_parsers, $parser) ;
		    } elsif ($type eq "path") {
			print "  Got path format '$title'\n" if $verbose_opt ;
			push (@internal_path_parsers, $parser) ;
		    }
		} elsif ($type or $title or $regexp or @indice_table) {
		    die "Incomplete format at line $. in file '$file'\n" ;
		}
		$type = undef ; $regexp = undef ; @indice_table = () ;
		$title = $1 ;
		# stocker la ligne ?
	    } elsif (/^type = (.*)$/) {
		die "Unsupported format type '$1' at line $. in file '$file'\n"
		    if $1 ne "filename" and $1 ne "path" ;
		$type = $1 ;
	    } elsif (/^regexp = (.*)$/) {
		$regexp = $1 ;
		$regexp =~ s/\./\\./g ;
		$regexp =~ s/\)/\\\)/g ;
		$regexp =~ s@/@\\/@g ;
		# do the replacement progressively so that %% and %x and not mixed
		while ($regexp =~ m/(%(?:P|L|S|N|A|%))/) {
		    if ($1 eq '%P') {
			$regexp =~ s/%P/$match_path/ ;
		    } elsif ($1 eq '%L') {
			$regexp =~ s/%L/$match_limit/ ;
		    } elsif ($1 eq '%S') {
			$regexp =~ s/%S/$match_space/ ;
		    } elsif ($1 eq '%N') {
			$regexp =~ s/%N/$match_num/ ;
		    } elsif ($1 eq '%A') {
			$regexp =~ s/%A/$match_any/ ;
		    } elsif ($1 eq '%%') {
			$regexp =~ s/%%/%/ ;
		    }
		}
	    } elsif (/^indices = (.*)$/) {
		@indice_table = split (/,/, $1) ;
		for(my $i = 0; $i < @indice_table; $i++) {
		    my $indice = ( grep { $field_letter[$_] eq $indice_table[$i] } ( 0 .. $fields-1 ) ) [0] ;
		    if (not defined $indice) {
			die "Unrecognized field letter '$indice_table[$i]' on line $. in file '$file'\n"
			    if $indice_table[$i] ne 'd' ;
			$indice = -1 ;
		    }
		    $indice_table[$i] = $indice ;
		}
	    } else {
		die "Unrecognized line $. in file '$file': '$_'\n" ;
	    }
	}
    close FORMAT ;
    }
}

# if -L was passed, show formats and exit
if ($list_formats_opt) {
    print "Listing internal parsers:\n" ;
    foreach my $path_parser (@internal_path_parsers) {
	foreach my $filename_parser (@internal_filename_parsers) {
	    print "  $path_parser->{title}/$filename_parser->{title}\n" ;
	}
    }
    exit 0 ;
}

#######################################################
# files to process

# process remaining command-line arguments as files
die "No files specified\n" if !@ARGV ;

my @files = () ;
while ( @ARGV ) {
    if ($recursive_opt) {
	my $dir = shift @ARGV ;
	open FIND, "find \"$dir\" |" ;
	my @dirfiles = <FIND> ;
	close FIND ;
	foreach my $file (@dirfiles) {
	    chomp $file ;
	    if (-f $file) {
		push (@files, $file) ;
	    }
	}
    } else {
	my $file = shift @ARGV ;
	if (-f $file) {
	    push (@files, $file) ;
	} else {
	    print "Skipping the non-file '$file'\n" ;
	}
    }
}

#######################################################
# merge path and filename internal parsers
sub merge_internal_parsers
{
    my $path_parser = shift ;
    my $filename_parser = shift ;
    my $parser ;
    $parser->{title} = "$path_parser->{title}/$filename_parser->{title}" ;
    $parser->{regexp} = "$path_parser->{regexp}/$filename_parser->{regexp}" ;
    $parser->{indices} = $path_parser->{indices} + $filename_parser->{indices} ;
    for(my $i=0; $i < $path_parser->{indices}; $i++) {
	$parser->{$i} = $path_parser->{$i} ;
    }
    for(my $i=0; $i < $filename_parser->{indices}; $i++) {
	$parser->{$i+$path_parser->{indices}} = $filename_parser->{$i} ;
    }
    return $parser ;
}

# parse
sub parse_file_with_internal_parsers
{
    my $file = shift ;
    my $filename = shift ;
    my $tag_type = shift ;

    print "  with internal formats...\n" ;

    # split into path and parts if possible
    my @parts = split (/\//, $filename) ;
    $filename = pop @parts ;

    if (!$nopath_opt and @parts) {
	# try each path parser and each filename parser
	my $path = join ("/", @parts) ;
	foreach my $path_parser (@internal_path_parsers) {
	    if ($path =~ /^$path_parser->{regexp}$/) {
		foreach my $filename_parser (@internal_filename_parsers) {
		    # match the whole path+filename to get a clean @_ for tag_with_parser
		    if ("$path/$filename" =~ m/^$path_parser->{regexp}\/$filename_parser->{regexp}$/) {
			print "    '$path_parser->{title}/$filename_parser->{title}' matches this file\n" ;
			my $whole_parser = merge_internal_parsers ($path_parser, $filename_parser) ;
			# try to tag, with confirmation
			my $res = tag_with_parser ($file, $tag_type, $whole_parser,
						   1, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER|$TAG_MAY_SKIP_PATH_PARSER, @_) ;
			if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERED || $res == $TAG_SKIP_FILE) {
			    if ($res == $TAG_SUCCESS_PREFERED) {
				$preferred_parser = $whole_parser ;
			    }
			    return $res ;
			}
			# try next path parser if asked
			if ($res == $TAG_SKIP_PATH_PARSER) {
			    goto NEXT_PATH_PARSER;
			}
			# try next parser
			die "Unknown tag return value: $res\n" if $res != $TAG_SKIP_PARSER ;
		    }
		}
	    }
	  NEXT_PATH_PARSER:
	}
    } else {
	# no path, only try each filename parser
	foreach my $filename_parser (@internal_filename_parsers) {
	    if ($filename =~ /^$filename_parser->{regexp}$/) {
		print "    '$filename_parser->{title}' matches this file\n" ;
		# try to tag, with confirmation
		my $res = tag_with_parser ($file, $tag_type, $filename_parser,
					   1, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER, @_) ;
		if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERED || $res == $TAG_SKIP_FILE) {
		    if ($res == $TAG_SUCCESS_PREFERED) {
			$preferred_parser = $filename_parser ;
		    }
		    return $res ;
		}
		# try next parser
		die "Unknown tag return value: $res\n" if $res != $TAG_SKIP_PARSER ;
	    }
	}
    }
    # no parser was found or used
    return 1 ;
}

#######################################################
# user parsers

# change format names into a parsing string
my $field_letters = (join '|', @field_letter).'|d' ;

# change a format strings into usable infos
sub generate_user_parser {
    my $format_string = shift ;

    print "Generating parser for format '". $format_string ."'...\n" ;

    my $parser ;
    $parser->{title} = $format_string ;

    # merge spaces if --spaces was passed
    if ($spaces_opt) {
	$format_string =~ s/ +/ /g ;
    }

    # create the regexp and store indice fields
    my @array = split(//, $format_string) ;
    my $j = 0 ;
    for(my $i = 0; $i < @array - 1; $i++) {

	# normal characters
	if ($array[$i] ne "%") {
	    if ($array[$i] eq " ") {
		# replace spaces with general space matching regexp
		$array[$i] = $match_space ;
	    } elsif ($array[$i] eq "/") {
		# replace / with space flexible matching regexp
		$array[$i] = $match_limit."/".$match_limit ;
	    }
	    # if that's not a %, keep it
	    next ;
	}

	# remove % and check next char
	splice (@array, $i, 1) ;
	# replace the char with the matching
	my $char = $array[$i] ;
	next if $char eq "%" ;
	if ($array[$i] eq "n") {
	    $array[$i] = $match_num ;
	} elsif ($array[$i] =~ /$field_letters/) {
	    $array[$i] = $match_any ;
	} else {
	    die "  ERROR: Format '". $format_string ."' contains unrecognized operator '%". $array[$i] ."'.\n" ;
	}
	# store the indice
	if ($char eq "d") {
	    $parser->{$j} = -1 ;
	} else {
	    my @indices = grep { $char eq $field_letter[$_] } ( 0 .. $fields-1 ) ;
	    $parser->{$j} = $indices[0] ;
	}
	$j++ ;
    }

    # done
    if ($spaces_opt) {
	$parser->{regexp} = $match_limit. join("", @array) .$match_limit ;
    } else {
	$parser->{regexp} = join("", @array) ;
    }
    $parser->{indices} = $j ;

    # check insolvable regexp
    for(my $i = 0; $i < @array - 1; $i++) {
	my $char = $array[$i] ;
	my $nextchar = $array[$i+1] ;
	if ( $char eq $match_any and
	     ( $nextchar eq $match_any or $nextchar eq $match_num ) ) {
	    print "  WARNING: Format '". $format_string
		."' leads to problematic subregexp '". $char.$nextchar
		."' that won't probably match as desired.\n" ;
	}
    }

    if ($verbose_opt) {
	print "  Format string will parse with: ". $parser->{regexp} ."\n" ;
	print "    Fields are: ". (join ';',
				 map ( $parser->{$_} ."(".
				       ( $parser->{$_} == -1 ? "d" : $field_letter[$parser->{$_}] )
				       .")" , (0..$j-1) )
				 )."\n" ;
    }

    return $parser ;
}

# user parsers
my @parsers = map ( generate_user_parser ($_), @format_strings ) ;

sub parse_file_with_user_parsers
{
    my $file = shift ;
    my $filename = shift ;
    my $tag_type = shift ;

    # try each format until one works
    foreach my $parser (@parsers) {
	print "  with format '". $parser->{title} ."'... " ;

	if ($filename =~ /^$parser->{regexp}$/) {
	    print "\n" ;
	    # try to tag, without confirmation
	    my $res = tag_with_parser ($file, $tag_type, $parser, 0, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER, @_) ;
	    if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERED || $res == $TAG_SKIP_FILE) {
		if ($res == $TAG_SUCCESS_PREFERED) {
		    $preferred_parser = $parser ;
		}
		return $res ;
	    }
	    # try next parser
	    die "Unknown tag return value: $res.\n" if $res != $TAG_SKIP_PARSER ;

	} else {
	    print "Does not match.\n" ;
	}
    }
    return 1 ;
}

#######################################################
# process files

while ( @files ) {
    my $file = shift @files ;

    print "Processing file \"".$file."\"...\n" ;

    # removing path if asked, only in $filename, keep $file complete
    my $filename = $file ;
    if ($nopath_opt && $filename =~ /\//) {
	$filename =~ s/.*\/([^\/]+)/$1/ ;
    }

    # split into filename and extension
    my @parts = split (/\./, $filename) ;
    my $extension = pop @parts ;
    $filename = join (".", @parts) ;

    # split into filename and extension
    my $tag_type = $type_opt ;
    if (not defined $tag_type) {
	if ($extension eq "ogg") {
	    $tag_type = $ogg_type ;
	} elsif ($extension eq "mp3") {
	    $tag_type = $mp3_type ;
	} else {
	    print "  Skipping this unknown-type file '$file'\n" ;
	    goto NEXT_FILE ;
	}
    }

    # try the prefered parser first
    if (defined $preferred_parser) {
	if ($filename =~ /^$preferred_parser->{regexp}$/) {
	    my $res = tag_with_parser ($file, $tag_type, $preferred_parser, 0, 0, @_) ;
	    # there can't be any confirmation here, SKIP is not possible
	    # only SUCCESS if possible
	    die "Unknown tag return value: $res.\n" if $res != $TAG_SUCCESS ;
	    goto NEXT_FILE ;
	} else {
	    print "  Preferred parser '$preferred_parser->{title}' does not match this file\n" ;
	    print "    Returning to original mode\n" ;
	    $current_ask_opt = $ask_opt ; $current_yes_opt = $yes_opt ;
	}
	$preferred_parser = undef ;
    }

    # try user provided parsers then
    if (parse_file_with_user_parsers($file, $filename, $tag_type) <= 0) {
	goto NEXT_FILE ;
    }

    # try to guess my internal format database then
    if ($guess_opt) {
	if (parse_file_with_internal_parsers($file, $filename, $tag_type) <= 0) {
	    goto NEXT_FILE ;
	}
    }

    # tag with default values only
    my @field = @field_default ;
    $#field = $fields-1 ;
    if ($guess_opt or @parsers) {
	print "  Didn't find any parser!\n" ;
    }
    my $res = confirm_and_tag ($file, $tag_type, 1, 0, @field) ;
    die "Unknown tag return value: $res.\n" if $res != $TAG_SUCCESS and $res != $TAG_SKIP_FILE ;

  NEXT_FILE:
    shift ;
}

#######################################################
# effective tagging

sub confirm_letters {
    my $behaviors = shift ;
    my $string = "[Yv" ;
    $string .= "u" if $behaviors & $TAG_MAY_PREFER ;
    $string .= "ae" ;
    $string .= "n" if $behaviors & $TAG_MAY_SKIP_PARSER ;
    $string .= "p" if $behaviors & $TAG_MAY_SKIP_PATH_PARSER ;
    $string .= "s,(h)elp]" ;
    return $string ;
}

sub confirm_usage {
    my $behaviors = shift ;
    print "        y => Yes, tag with this format (default)\n" ;
    print "        v => View which fields would be set\n" ;
    print "        u => Use this format for all files until one does not match\n"
	if $behaviors & $TAG_MAY_PREFER ;
    print "        a => Always yes, stop asking for a confirmation\n" ;
    print "        e => Edit these fields before tagging\n" ;
    print "        n => No, try the next matching format\n"
	if $behaviors & $TAG_MAY_SKIP_PARSER ;
    print "        p => No, try the next path matching format\n"
	if $behaviors & $TAG_MAY_SKIP_PATH_PARSER ;
    print "        s => Skip this file, don't tag it\n" ;
    print "        h => Show this help\n" ;
}

sub tag_with_parser {
    my $file = shift ;
    my $tag_type = shift ;
    my $parser = shift ;
    my $confirm = shift ;
    my $behaviors = shift ;

    # get default fields (without modifying the original)
    my @field = @field_default ;
    $#field = $fields-1 ;

    # set to 1 when the field is defined (not by default)
    my @field_set = () ;
    $#field_set = $fields-1 ;

    # get fields and show them if asked
    my $i = 1 ;
    while ( $i <= $parser->{indices} ) {
        my $indice = $parser->{$i-1};
	if ( $indice >= 0 ) {
	    my $val = ${$i} ;
	    $val =~ s/($sep_opt)/ /g if (defined $sep_opt) ;
	    if ($field_set[$indice]) {
		print "      WARNING: ".ucfirst($field_name[$indice])." already set to '".$field[$indice]
		    ."', skipping new value '$val'.\n" if ($field[$indice] ne $val) ;
		goto NEXT_FIELD ;
	    }
	    $field[$indice] = $val ;
	    $field_set[$indice] = 1 ;
	    if ($verbose_opt or $confirm or $current_ask_opt) {
		print "      ". ucfirst($field_name[$indice])
		    .$field_trailing_spaces[$indice]
		    .": ". $val ."\n" ;
	    }
	}
     NEXT_FIELD:
	$i++ ;
    }

    return confirm_and_tag ($file, $tag_type, $confirm, $behaviors, @field) ;
}

sub confirm_and_tag {
    my $file = shift ;
    my $tag_type = shift ;
    my $confirm = shift ;
    my $behaviors = shift ;

    # remaining args are fields
    my @field ;
    for(my $i = 0; $i < $fields; $i++) {
	$field[$i] = shift;
    }

    # prefer this type of tagging ?
    my $prefered = 0 ;

    # confirm if required
    if ($current_ask_opt or ($confirm and !$current_yes_opt)) {
      ASK_CONFIRM:
	print "      Really tag the file ".(confirm_letters ($behaviors))." ? " ;
	my $reply = <> ;
	chomp $reply ;
	if ($reply eq "" or $reply =~ /^y/i) {
	    goto TAG_IT ;
	} elsif ($reply eq "v") {
	    for(my $i = 0; $i < $fields; $i++) {
		print "        ".ucfirst($field_name[$i]).$field_trailing_spaces[$i].": ".$field[$i]."\n" if defined $field[$i] ;
	    }
	    goto ASK_CONFIRM ;
	} elsif ($reply =~ /^a/i) {
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto TAG_IT ;
	} elsif ($behaviors & $TAG_MAY_PREFER and $reply =~ /^u/i) {
	    $prefered = 1 ;
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto TAG_IT ;
	} elsif ($behaviors & $TAG_MAY_SKIP_PARSER and $reply =~ /^n/i) {
	    return $TAG_SKIP_PARSER ;
	} elsif ($behaviors & $TAG_MAY_SKIP_PATH_PARSER and $reply =~ /^p/i) {
	    return $TAG_SKIP_PATH_PARSER ;
	} elsif ($reply =~ /^s/i) {
	    return $TAG_SKIP_FILE ;
	} elsif ($reply =~ /^e/i) {

	    my @edit_field = @field ;
	    $#edit_field = $fields-1 ;
	  ASK_EDIT:
	    print "        Edit a field [atAngyec,(h)elp] ? " ;
	    my $edit_reply = <> ;
	    chomp $edit_reply ;
	    if ($edit_reply =~ /^($field_letters)$/) {
		my $i = ( grep { $edit_reply eq $field_letter[$_] } ( 0 .. $fields-1 ) ) [0] ;
		print "          Enter ".ucfirst($field_name[$i])." field (" ;
		print "<enter> to keep '".$edit_field[$i]."', " if defined $edit_field[$i] ;
		print "CLEAR to clear): " ;
		my $val = <> ;
		chomp $val ;
		if ($val) {
			$val = "" if $val eq "CLEAR" ;
			$edit_field[$i] = $val ;
		}
		goto ASK_EDIT ;
	    } elsif ($edit_reply eq "e") {
		@field = @edit_field ;
		goto TAG_IT ;
	    } elsif ($edit_reply eq "c") {
		goto ASK_CONFIRM ;
	    } else {
		for(my $i = 0; $i < $fields; $i++) {
		    my $val = $edit_field[$i];
		    $val = "<unchanged>" if not defined $val ;
		    print "          ".$field_letter[$i]." => Edit ".ucfirst($field_name[$i]).$field_trailing_spaces[$i]." (='".$val."')\n" ;
		}
		print "          e => End edition and tag\n" ;
		print "          c => Cancel edition\n" ;
		goto ASK_EDIT ;
	    }

	} else {
	    confirm_usage ($behaviors) ;
	    goto ASK_CONFIRM ;
	}
    }

  TAG_IT:
    my $res = tag_with_fields ($file, $tag_type, @field) ;
    return $TAG_SUCCESS_PREFERED if $prefered and $res == $TAG_SUCCESS ;
    return $res ;
}

sub tag_with_fields {
    my $file = shift ;
    my $tag_type = shift ;

    # remaining args are fields
    my @field ;
    for(my $i = 0; $i < $fields; $i++) {
	$field[$i] = shift;
    }

    # is there actually something to do ?
    if ( ! grep { defined $field[$_] } ( 0 ... $fields-1 ) ) {
	print "      Nothing to do.\n" ;
	return $TAG_SUCCESS ;
    }

    # tagging command line
    my @system_args ;
    if ($tag_type eq $ogg_type) {
	@system_args =
	    ( "vorbiscomment", "-wq", ( map { ( "-t" , $field_vorbiscomment_option[$_]."=".$field[$_] ) }
		( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
		) ,
	      $file
	      ) ;
    } elsif ($tag_type eq $mp3_type) {
	@system_args =
	    ( "mp3info" ,
	      ( map { ( "-".$field_mp3info_option[$_] , $field[$_] ) }
		( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
		) ,
	      $file
	      ) ;
	    }

    # show command line and really tag if asked
    if ($dryrun_opt or $verbose_opt) {
	print "      ". +(join '# #', @system_args) ."\n" ;
	}
    if (!$dryrun_opt) {
	print "      Tagging.\n" ;
	system @system_args ;
    }

    return $TAG_SUCCESS ;
}
