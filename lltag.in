#!/usr/bin/perl -w

use strict ;
no strict "refs" ; # for $backend{$file_type}

require Lltag::Tags ;
require Lltag::Misc ;
require Lltag::MP3 ;
require Lltag::OGG ;
require Lltag::FLAC ;
require Lltag::CDDB ;
require Lltag::Parse ;
require Lltag::Rename ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

#######################################################
# main hash for globals and config
my $self = {} ;

#######################################################
# configuration file location
$self->{common_lltag_dir} = "@SYSCONFDIR@/lltag" ;
$self->{user_lltag_dir} = "$ENV{HOME}/.lltag" ;
$self->{lltag_format_filename} = "formats" ;
$self->{lltag_config_filename} = "config" ;
$self->{lltag_edit_history_filename} = "edit_history" ;

#######################################################
Lltag::Misc::init_readline ($self) ;

#######################################################
# format parameters

@{$self->{field_names}} = ('ARTIST', 'TITLE', 'ALBUM', 'NUMBER', 'GENRE', 'DATE', 'COMMENT') ;
@{$self->{field_letters}} = ('a', 't', 'A', 'n', 'g', 'd', 'c') ;

%{$self->{field_name_letter}} =
    (
     'ARTIST'  => 'a',
     'TITLE'   => 't',
     'ALBUM'   => 'A',
     'NUMBER'  => 'n',
     'GENRE'   => 'g',
     'DATE'    => 'd',
     'COMMENT' => 'c',
     ) ;

%{$self->{field_name_trailing_spaces}} =
    (
     'ARTIST' => '  ',
     'TITLE' => '   ',
     'ALBUM' => '   ',
     'NUMBER' => '  ',
     'GENRE' => '   ',
     'DATE' => '    ',
     'COMMENT' => ' ',
     ) ;

%{$self->{field_default}} = () ;

%{$self->{field_letter_name}} =
    (
     'a' => 'ARTIST',
     't' => 'TITLE',
     'A' => 'ALBUM',
     'n' => 'NUMBER',
     'g' => 'GENRE',
     'd' => 'DATE',
     'c' => 'COMMENT',
     ) ;

# change format letters into a parsing string
$self->{field_letters_union} = (join '|', @{$self->{field_letters}}) ;
# cache the list of letters for later
$self->{field_letters_string} = (join '', @{$self->{field_letters}}) ;

#######################################################
# version
my $version = "@VERSION@" ;

sub version {
    print "This is lltag version $version.\n" ;
    exit 0 ;
}

#######################################################
# usage
sub usage {
    print $0." $version is a frontend to tag and rename MP3/OGG/FLAC files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print " Tagging options:\n" ;
    print "  -F, --format <format>  Try format (multiple instances allowed)\n" ;
    print "  -G, --guess            Guess format (default)\n" ;
    print "  -C, --cddb             Query tags in CDDB\n" ;
    print "  -E, --edit             Edit tags\n" ;
    print map { "  -". $self->{field_name_letter}{$_} .", --". $_.$self->{field_name_trailing_spaces}{$_}
		    ."<val>    Set the default value for ". ucfirst($_) ."\n" } @{$self->{field_names}} ;
    print "  --tag <TAG=value>      Add <value> to tag <TAG>\n" ;
    print "  -p, --no-path          Remove the path from filenames when matching\n" ;
    print "  --spaces               Allow no or multiple spaces\n" ;
    print "  --maj                  Upcase first letters of words in tags\n" ;
    print "  --sep <s1|s2|...>      Replace |-separated strings with space in tags\n" ;
    print "  --regexp <regexp>      Apply a replace regexp to tags before tagging\n" ;
    print "  --mp3/--ogg/--flac     Force mp3, ogg or flac instead of by-extension detection\n" ;
    print "  --type <type>          Force <tyle> instead of by-extension detection\n" ;
    print "  --clear                Clear all tags of audio files when possible\n" ;
    print "  --append               Append tags only instead of replacing old ones when possible\n" ;
    print "  --no-tagging           Do not actually tag files\n" ;
    Lltag::Rename::rename_usage ($self) ;
    print " General options:\n" ;
    print "  --dry-run              Do nothing but show what would have been done\n" ;
    print "  --yes                  Tag without asking for confirmation when guessing\n" ;
    print "                         Rename without asking for confirmation\n" ;
    print "  --ask                  Always ask for confirmation before tagging\n" ;
    print "  -R, --recursive        Recursively search all files in subdirectories\n" ;
    print "  -v, --verbose          More verbose messages\n" ;
    print "  -q, --quiet            Less verbose messages\n" ;
    print "  --config <file>        Read additional configuration file\n" ;
    print "  --gencfg <file>        Generate additional configuration file\n" ;
    print " CDDB options:\n" ;
    print "  --cddb-query <query>   Start with CDDB query <query> by keywords or id\n" ;
    print "  --cddb-server <server> Change the CDDB server and port\n" ;
    print " Behavior options:\n" ;
    print "  -S                     Show all tags from files\n" ;
    print "  --show-tags <tag,..>   Show several tags from files\n" ;
    print "  -L, --list             List internal formats\n" ;
    print "  -V, --version          Show lltag version\n" ;
    print "  -h, --help             Show this help\n" ;
    print " Format is composed of anything you want with special fields:\n" ;
    print map { "  %". $self->{field_name_letter}{$_} ." means ". ucfirst($_) ."\n" } @{$self->{field_names}} ;
    Lltag::Parse::parsing_format_usage ($self) ;
    Lltag::Rename::rename_format_usage ($self) ;
    print "\n" ;
    print "Author:    Brice Goglin\n" ;
    print "Homepage:  http://home.gna.org/lltag\n" ;
    print "Report bugs to:  <lltag-users AT gna.org>\n" ;
    exit 1;
}

#######################################################
# options

my $verbose_level = 1 ; # only display usage when menu appear for the first time

$self->{dry_run_opt} = 0 ;
$self->{recursive_opt} = 0 ;
$self->{list_formats_opt} = 0 ;
$self->{show_tags_opt} = "" ;
$self->{no_tagging_opt} = 0 ;

%{$self->{additional_values}} = () ;

$self->{ask_opt} = 0 ;
$self->{guess_opt} = 0 ;
$self->{cddb_opt} = 0 ;
$self->{edit_opt} = 0 ;
$self->{no_path_opt} = 0 ;
$self->{maj_opt} = 0 ;
$self->{sep_opt} = undef ;
$self->{spaces_opt} = 0 ;
$self->{type_opt} = undef ;
$self->{yes_opt} = 0 ;
$self->{clear_opt} = 0 ;
$self->{append_opt} = 0 ;
@{$self->{regexp_opts}} = () ;

$self->{rename_opt} = undef ;
$self->{rename_min_opt} = 0 ;
$self->{rename_sep_opt} = " " ;
$self->{rename_ext_opt} = 0 ;
@{$self->{rename_regexp_opts}} = () ;

$self->{gencfg_file} = undef ;

@{$self->{user_format_strings}} = () ;

$self->{cddb_server_name} = "tracktype.org" ;
$self->{cddb_server_port} = 80 ;

# command line given cddb query, undefined afterwards
$self->{requested_cddb_query} = undef ;

#######################################################
# parse config files first

my @additional_config_files = () ;

# process these options but kept other options in @ARGV for later
Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'config=s'     => \@additional_config_files,
	   ) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

sub process_option {
    $_ = shift ;
    chomp $_ ;
    if (/^format\s*=\s*"(.+)"$/) {
	push (@{$self->{user_format_strings}}, $1) ;
    } elsif (/^guess\s*=\s*(.+)$/) {
	$self->{guess_opt} = $1 ;
    } elsif (/^no_path\s*=\s*(.+)$/) {
	$self->{no_path_opt} = $1 ;
    } elsif (/^default_([^ ]*)\s*=\s*"(.*)"$/) {
	die "Unrecognized option line #$.: \"$_\"\n"
	    # TODO: drop non-capitalized field name support on september 20 2006
	    unless defined $self->{field_name_letter}{uc ($1)} ;
	# TODO: drop filename support on september 20 2006
	$self->{field_default}{uc ($1)} = $2 ;
    } elsif (/^tag\s*=\s*"(.+)"$/) {
	Lltag::Tags::process_additional_tag_value ($self, $1) ;
    } elsif (/^spaces\s*=\s*(.+)$/) {
	$self->{spaces_opt} = $1 ;
    } elsif (/^maj\s*=\s*(.+)$/) {
	$self->{maj_opt} = $1 ;
    } elsif (/^sep\s*=\s*"(.*)"$/) {
	$self->{sep_opt} = $1 ;
    } elsif (/^type\s*=\s*(.+)$/) {
	if ($1 eq "none") {
	    $self->{type_opt} = undef ;
	} else {
	    $self->{type_opt} = $1 ;
	}
    } elsif (/^regexp\s*=\s*"(.+)"$/) {
	push (@{$self->{regexp_opts}}, $1) ;
    } elsif (/^clear_tags\s*=\s*(.+)$/) {
	$self->{clear_opt} = $1 ;
    } elsif (/^append_tags\s*=\s*(.+)$/) {
	$self->{append_opt} = $1 ;
    } elsif (/^no_tagging\s*=\s*(.+)$/) {
	$self->{no_tagging_opt} = $1 ;
    } elsif (/^rename_format\s*=\s*"(.*)"$/) {
	if ($1 eq "") {
	    $self->{rename_opt} = undef ;
	} else {
	    $self->{rename_opt} = $1 ;
	}
    } elsif (/^rename_min\s*=\s*(.+)$/) {
	$self->{rename_min_opt} = $1 ;
    } elsif (/^rename_sep\s*=\s*"(.*)"$/) {
	$self->{rename_sep_opt} = $1 ;
    } elsif (/^rename_regexp\s*=\s*"(.+)"$/) {
	push (@{$self->{rename_regexp_opts}}, $1) ;
    } elsif (/^rename_ext\s*=\s*(.+)$/) {
	$self->{rename_ext_opt} = $1 ;
    } elsif (/^dry_run\s*=\s*(.+)$/) {
	$self->{dry_run_opt} = $1 ;
    } elsif (/^yes\s*=\s*(.+)$/) {
	$self->{yes_opt} = $1 ;
	$self->{ask_opt} = 0 if $1 ;
    } elsif (/^ask\s*=\s*(.+)$/) {
	$self->{ask_opt} = $1 ;
	$self->{yes_opt} = 0 if $1 ;
    } elsif (/^recursive\s*=\s*(.+)$/) {
	$self->{recursive_opt} = $1 ;
    } elsif (/^verbose\s*=\s*(.+)$/) {
	$verbose_level = $1 ;
    } elsif (/^cddb\s*=\s*(.+)$/) {
	$self->{cddb_opt} = $1 ;
    } elsif (/^cddb_server_name\s*=\s*"(.+)"$/) {
	$self->{cddb_server_name} = $1 ;
    } elsif (/^cddb_server_port\s*=\s*(\d+)$/) {
	$self->{cddb_server_port} = $1 ;
    } elsif (/^edit = \s*(.+)$/) {
	$self->{edit_opt} = $1 ;
# Error
    } elsif (/^[^#]/ && !/^(\s*)$/) {
	die "Unrecognized option line #$.: \"$_\"\n" ;
    }
}

sub parse_generic_config_file {
    my $file = shift ;
    open CONF, $file
	or return ;
    while (<CONF>) {
	process_option $_ ;
    }
    close CONF ;
}

parse_generic_config_file "$self->{common_lltag_dir}/$self->{lltag_config_filename}" ;
parse_generic_config_file "$self->{user_lltag_dir}/$self->{lltag_config_filename}" ;

sub parse_additional_config_file {
    my $file = shift ;
    open CONF, $file
	or die "Failed to open additional configuration file '$file' ($!).\n" ;
    while (<CONF>) {
	process_option $_ ;
    }
    close CONF ;
}

foreach my $file (@additional_config_files) {
    parse_additional_config_file $file ;
}

#######################################################
# parse cmdline options

# parse options
GetOptions(
	   'F|format=s'		=> \@{$self->{user_format_strings}},
	   'G|guess'		=> \$self->{guess_opt},
	   'C|cddb'		=> \$self->{cddb_opt},
	   'E|edit'		=> \$self->{edit_opt},
	   'p|no-path'		=> \$self->{no_path_opt},
	   'spaces'		=> \$self->{spaces_opt},
	   'maj'		=> \$self->{maj_opt},
	   'sep=s'		=> \$self->{sep_opt},
	   'regexp=s'		=> \@{$self->{regexp_opts}},
	   # we do not use backends here since it would require to load them
	   # before parsing the command-line, and is useless anyway
	   'mp3'		=> sub { $self->{type_opt} = "mp3" ; },
	   'ogg'		=> sub { $self->{type_opt} = "ogg" ; },
	   'flac'		=> sub { $self->{type_opt} = "flac" ; },
	   'type=s'		=> sub { shift ; $self->{type_opt} = shift ; },
	   'clear'		=> \$self->{clear_opt},
	   'append'		=> \$self->{append_opt},
	   'no-tagging'		=> \$self->{no_tagging_opt},
	   'rename=s'		=> \$self->{rename_opt},
	   'rename-min'		=> \$self->{rename_min_opt},
	   'rename-sep=s'	=> \$self->{rename_sep_opt},
	   'rename-regexp=s'	=> \@{$self->{rename_regexp_opts}},
	   'rename-ext'		=> \$self->{rename_ext_opt},
	   'dry-run'		=> \$self->{dry_run_opt},
	   'R|recursive'	=> \$self->{recursive_opt},
	   'yes'		=> sub { $self->{yes_opt} = 1 ; $self->{ask_opt} = 0 ; },
	   'ask'		=> sub { $self->{ask_opt} = 1 ; $self->{yes_opt} = 0 ; },
	   'cddb-server=s'	=> sub { shift ; my $name = shift ;
					 if ($name =~ m/(.*):(.*)/) {
					     $self->{cddb_server_name} = $1 ;
					     $self->{cddb_server_port} = $2 ;
					 } else {
					     $self->{cddb_server_name} = $name ;
					     $self->{cddb_server_port} = 80 ;
					 }
				       },
	   'cddb-query=s'	=> \$self->{requested_cddb_query},
	   'v|verbose'		=> sub { shift ; $verbose_level++ ; },
	   'q|quiet'		=> sub { shift ; $verbose_level-- ; },
	   'gencfg=s'		=> \$self->{gencfg_file},
	   'h|help'		=> sub { usage () ; },
	   'V|version'		=> sub { version () ; },
	   'L|list'		=> \$self->{list_formats_opt},
	   'show-tags=s'	=> \$self->{show_tags_opt},
	   'S'			=> sub { $self->{show_tags_opt} = "all" ; },
	   'tag=s'		=> sub { shift ; Lltag::Tags::process_additional_tag_value ($self, shift) ; },
	   map { my $field = $_ ;
		 # use a sub because \$self->{field_default}{$field} always allocates it and assigns it to undef...
		 $self->{field_name_letter}{$field} .'|'. $field .'=s' => sub { shift ; $self->{field_default}{$field} = shift },
	       } @{$self->{field_names}} ,
	   ) or usage () ;

# set verbosity options depending of the level
$self->{verbose_opt} = ($verbose_level > 1) ;
$self->{menu_usage_once_opt} = ($verbose_level > 0) ;

# if --cddb-query is passed, enable cddb too
$self->{cddb_opt} = 1
    if defined $self->{requested_cddb_query} ;

# yes/ask option status may vary with user confirmation replies
my $current_main_yes_opt = $self->{yes_opt} ;
Lltag::CDDB::init_cddb ($self) ;
Lltag::Parse::init_parsing ($self) ;
Lltag::Tags::init_tagging ($self) ;
Lltag::Rename::init_renaming ($self) ;

#######################################################
# backends

# hash backends by type
my %backends = () ;

# hash types by file extention
my %file_extension_to_backend_type = () ;

# return 0 on success, -1 on error, 1 on busy
sub register_backend {
    my $backend = shift ;
    return -1
	if not defined $backend ;

    my $backend_extension = $backend->{extension} ;
    my $backend_type = $backend->{type} ;
    my $backend_name = $backend->{name} ;

    if (defined $backends{$backend_type}) {
	print "Failed to register backend '$backend_name' since file type '$backend_type' already exists.\n"
	    if $self->{verbose_opt} ;
	return 1 ;
    }
    if (defined $file_extension_to_backend_type{$backend_extension}) {
	print "Failed to register backend '$backend_name' since file extenstion '$backend_extension' already exists.\n"
	    if $self->{verbose_opt} ;
	return 1 ;
    }

    $backends{$backend_type} = $backend ;
    $file_extension_to_backend_type{$backend_extension} = $backend_type ;

    print "Registered backend '$backend_name' for type '$backend_type' extension '$backend_extension'.\n"
	if $self->{verbose_opt} ;

    return 0 ;
}

# register MP3 backend
register_backend (Lltag::MP3::new ($self)) ;

# register OGG backend
register_backend (Lltag::OGG::new ($self)) ;

# register FLAC backend
register_backend (Lltag::FLAC::new ($self)) ;

#######################################################
# check that the file type is correct

die "Unrecognized file type '$self->{type_opt}'.\n"
    if defined $self->{type_opt} and not defined $backends{$self->{type_opt}} ;

#######################################################
# extract backend and parsename

sub extract_parsename_and_backend {
    my $file = shift ;

    # split into parsename and extension, and remove the path if asked
    my @parts = split (/\./, $file) ;
    my $extension = pop @parts ;
    my $parsename = join (".", @parts) ;
    if ($self->{no_path_opt}) {
	my @parts = split (/\//, $parsename) ;
	$parsename = pop @parts ;
    }

    my $file_type ;
    if (defined $self->{type_opt}) {
	$file_type = $self->{type_opt} ;
    } else {
	# if not forced, get the type from the extension
	$file_type = $file_extension_to_backend_type{lc($extension)} ;
    }

    return ($parsename, undef)
	unless defined $file_type ;

    return ($parsename, $backends{$file_type}) ;
}

#######################################################
# show existing tags if --show-tags was passed

sub read_tags {
    my $file = shift ;
    my $backend = shift ;

    # extract tags as a stream
    my $read_tags_func = $backend->{read_tags} ;
    my $values = &$read_tags_func ($self, $file) ;
    Lltag::Misc::print_warning ("  ", "Failed to get tags from file.")
	unless defined $values ;
    return $values ;
}

#######################################################
# real tagging

sub tag_with_values {
    my $file = shift ;
    my $backend = shift ;
    my $values = shift ;

    # tagging command line
    my $set_tags_func = $backend->{set_tags} ;
    &{$set_tags_func}($self, $file, $values) ;
}

#######################################################
# add defaults and additional_values

sub add_defaults {
    my $self = shift ;
    my $values = shift ;

    # add new values to the old ones, depending on clear/append options
    my $new_values = Lltag::Tags::clone_tag_values ($values) ;
    Lltag::Tags::append_tag_values ($self, $new_values, $self->{additional_values}) ;

    # then add defaults to not defined tags
    foreach my $field (@{$self->{field_names}}) {
	$new_values->{$field} = $self->{field_default}{$field}
	    if not defined $new_values->{$field} and defined $self->{field_default}{$field} ;
    }

    return $new_values ;
}

#######################################################
# wrappers for all tag-obtention routines

sub try_to_parse_with_preferred {
    my $self = shift ;
    my $file = shift ;
    my $parsename = shift ;
    my $old_values = shift ;

    my ($res, $new_values) = Lltag::Parse::try_to_parse_with_preferred ($self, $file, $parsename) ;
    if ($res == Lltag::Parse->PARSE_SUCCESS) {
	return Lltag::Tags::merge_new_tag_values ($self, $old_values,
						  (add_defaults $self, $new_values));
    }

    # sanity check
    die "Unknown tag return value: $res.\n"
	unless $res == Lltag::Parse->PARSE_NO_MATCH ;

    return undef ;
}

sub try_to_parse {
    my $self = shift ;
    my $file = shift ;
    my $parsename = shift ;
    my $try_internals = shift ;
    my $old_values = shift ;

    my ($res, $new_values) = Lltag::Parse::try_to_parse ($self, $file, $parsename, $try_internals) ;
    if ($res == Lltag::Parse->PARSE_SUCCESS or $res == Lltag::Parse->PARSE_SUCCESS_PREFERRED) {
	return Lltag::Tags::merge_new_tag_values ($self, $old_values,
						  (add_defaults $self, $new_values));
    }

    # sanity check
    die "Unknown tag return value: $res.\n"
	unless $res == Lltag::Parse->PARSE_NO_MATCH or $res == Lltag::Parse->PARSE_ABORT ;

    return undef ;
}

sub try_cddb {
    my $self = shift ;
    my $old_values = shift ;

    my ($res, $new_values) = Lltag::CDDB::get_cddb_tags ($self) ;
    if ($res == Lltag::CDDB->CDDB_SUCCESS) {
	return Lltag::Tags::merge_new_tag_values ($self, $old_values,
						  (add_defaults $self, $new_values));
    }

    # sanity check
    die "Unknown CDDB return value: $res.\n"
	unless $res == Lltag::CDDB->CDDB_ABORT ;

    return undef ;
}

#######################################################
# main confirmation loop

my $main_confirm_menu_usage_forced = $self->{menu_usage_once_opt} ;

sub main_confirm_menu_usage {
    Lltag::Misc::print_usage_header ("  ", "Main menu") ;

    print "    y => Yes, use these tags (default)\n" ;
    print "    a => Always yes, stop asking for a confirmation\n" ;
    print "    P => Try to parse the file\n" ;
    print "    C => Query CDDB\n" ;
    print "    E => Edit values\n" ;
    print "    D => Only use default values\n" ;
    print "    Z => Reset to no values\n" ;
    print "    R => Revert to old values\n" ;
    print "    O => Display old values\n" ;
    print "    n => Skip tagging and jump to rename\n" ;
    print "    s/q => Skip this file\n" ;
    print "    Q => Quit without tagging anything anymore\n" ;
    print "    h => Show this help\n" ;

    $main_confirm_menu_usage_forced = 0 ;
# TODO update
}

use constant CONFIRM_TAG => 1 ;
use constant CONFIRM_DONT_TAG => 2 ;
use constant CONFIRM_SKIP_FILE => -1 ;
use constant CONFIRM_EXIT => -2 ;

sub main_confirm_menu {
    my $self = shift ;
    my $file = shift ;
    my $parsename = shift ;
    my $current_values = shift ;
    my $old_values = shift ;

    while (1) {
	# display current values
	if (keys %{$current_values}) {
	    print "    Current tag values are:\n" ;
	    Lltag::Tags::display_tag_values ($self, $current_values, "      ") ;
	} else {
	    print "    There are no current tag values.\n" ;
	}

	# display the menu once
	main_confirm_menu_usage
	    if $main_confirm_menu_usage_forced ;
	# ask the user for confirmation
	my $confirm_reply = Lltag::Misc::readline ("  ", "Use these tag values [yaPCEDZROnqQ] (default is yes, h for help)", "", -1) ;

	# if ctrl-d, skip this file
	$confirm_reply = 'q' unless defined $confirm_reply ;

	if ($confirm_reply =~ m/^y/ or $confirm_reply eq "") {
	    return (CONFIRM_TAG, $current_values)

	} elsif ($confirm_reply =~ m/^a/) {
	    $current_main_yes_opt = 1 ;
	    return (CONFIRM_TAG, $current_values)

	} elsif ($confirm_reply =~ m/^n/) {
	    print "    Skipping tagging for this file...\n" ;
	    return (CONFIRM_DONT_TAG, $current_values)

	} elsif ($confirm_reply =~ m/^s/ or $confirm_reply =~ m/^q/) {
	    return (CONFIRM_SKIP_FILE, undef) ;

	} elsif ($confirm_reply =~ m/^Q/) {
	    return (CONFIRM_EXIT, undef) ;

	} elsif ($confirm_reply =~ m/^P/) {
	    my $new_values = try_to_parse ($self, $file, $parsename, 1, $old_values) ;
	    $current_values = $new_values
		if defined $new_values ;

	} elsif ($confirm_reply =~ m/^C/) {
	    my $new_values = try_cddb ($self, $old_values) ;
	    $current_values = $new_values
		if defined $new_values ;

	} elsif ($confirm_reply =~ m/^E/) {
	    $current_values = Lltag::Tags::edit_values ($self, $current_values) ;

	} elsif ($confirm_reply =~ m/^D/) {
	    $current_values = add_defaults $self, $old_values ;

	} elsif ($confirm_reply =~ m/^Z/) {
	    $current_values = {} ;

	} elsif ($confirm_reply =~ m/^R/) {
	    $current_values = Lltag::Tags::clone_tag_values ($old_values) ;

	} elsif ($confirm_reply =~ m/^O/) {
	    # display old values
	    if (keys %{$old_values}) {
		print "      Existing tag values were:\n" ;
		Lltag::Tags::display_tag_values ($self, $old_values, "        ") ;
	    } else {
		print "    There were no tag values.\n" ;
	    }

	} else {
	    main_confirm_menu_usage ;
	}
    }
}

#######################################################
# main process

# if -L was passed, show formats and exit
if ($self->{list_formats_opt}) {
    # read internal parsers
    Lltag::Parse::read_internal_parsers ($self) ;
    # list them
    print "Listing internal parsers:\n" ;
    Lltag::Parse::list_internal_parsers () ;
    exit 0 ;
}

# process remaining command-line arguments as files
my @files = () ;
while ( @ARGV ) {
    if ($self->{recursive_opt}) {
	my $dir = shift @ARGV ;
	open FIND, "find \"$dir\" |" ;
	my @dirfiles = <FIND> ;
	close FIND ;
	foreach my $file (@dirfiles) {
	    chomp $file ;
	    if (-f $file) {
		push (@files, $file) ;
	    }
	}
    } else {
	my $file = shift @ARGV ;
	if (-f $file) {
	    push (@files, $file) ;
	} else {
	    print "Skipping the non-file '$file'\n" ;
	}
    }
}

if (!@files) {
    print "No files to process.\n"
	if $self->{verbose_opt} ;
    exit 0 ;
}

# display tags
if ($self->{show_tags_opt}) {
    my @fields_to_show = split (/,/, $self->{show_tags_opt}) ;
    foreach my $file (@files) {
	print "$file:\n"
	    if @files ; # do not print filename if there is only one file

	my ($parsename, $backend) = extract_parsename_and_backend $file ;
	if (not defined $backend) {
	    print "  Skipping this unknown-type file.\n" ;
	    next ;
	}

	my $values = read_tags $file, $backend ;

	foreach my $field (@{$self->{field_names}}, (Lltag::Tags::get_values_non_regular_keys ($self, $values))) {
	    next if not defined $values->{$field} ;
	    next unless grep { /^all$/ } @fields_to_show
		or grep { /^$field$/i } @fields_to_show ;
	    map { print "  $field=$_\n" } (Lltag::Tags::get_tag_value_array ($self, $values, $field)) ;
	}
    }

    exit 0 ;
}

# main reading/parsing/tagging/renaming loop
while ( @files ) {
    my $file = shift @files ;
    my $res ;

    print "\n" ;
    print "Processing file \"".$file."\"...\n" ;

    my ($parsename, $backend) = extract_parsename_and_backend $file ;
    if (not defined $backend) {
	print "  Skipping this file '$file' with unknown type.\n" ;
	goto NEXT_FILE ;
    }

    # read old tags
    my $old_values = read_tags $file, $backend ;

    # FIXME: read the tracknumber and pass it to cddb ?
    # FIXME: parse first, to get the track number?

    my $current_values = undef ;

    # try preferred parser first
    {
	my $new_values = try_to_parse_with_preferred $self, $file, $parsename, $old_values ;
	if (defined $new_values) {
	    $current_values = $new_values ;
	    goto CONFIRM ;
	}
    }

    # edit, if enabled
    if ($self->{edit_opt}) {
	my $new_values = Lltag::Tags::edit_values ($self, $old_values, $self->{field_names}) ;
	if ($new_values != $old_values) {
	    $current_values = $new_values ;
	    goto CONFIRM
	}
    }

    # try CDDB, if enabled
    if ($self->{cddb_opt}) {
	my $new_values = try_cddb $self, $old_values ;
	if (defined $new_values) {
	    $current_values = $new_values ;
	    goto CONFIRM ;
	}
    }

    # try to parse with all parsers, either user-provided or internals
    # if guess or any user-parser or NOTHING else enabled
    if ($self->{guess_opt}
	or @{$self->{user_format_strings}}
	or ( !(grep { defined $self->{field_default}{$_} } (keys %{$self->{field_default}}))
	     and !(keys %{$self->{additional_values}})
	     and !$self->{cddb_opt}
	     and !$self->{edit_opt}
	     and !$self->{rename_opt}
	) ) {
	# force guess if NOTHING enabled
	my $try_internals = ($self->{guess_opt}
			     or ( !@{$self->{user_format_strings}}
				  and !(grep { defined $self->{field_default}{$_} } (keys %{$self->{field_default}}))
				  and !(keys %{$self->{additional_values}})
				  and !$self->{cddb_opt}
				  and !$self->{edit_opt}
				  and !$self->{rename_opt}
				  ) ) ;

	my $new_values = try_to_parse $self, $file, $parsename, $try_internals, $old_values ;
	if (defined $new_values) {
	    $current_values = $new_values ;
	    goto CONFIRM ;
	}
    }

    $current_values = add_defaults $self, $old_values ;

  CONFIRM:
    if ($current_main_yes_opt) {
	$res = CONFIRM_TAG ;
    } else {
	($res, $current_values) = main_confirm_menu $self, $file, $parsename, $current_values, $old_values ;
    }

    if ($res == CONFIRM_EXIT) {
	print "  Exiting...\n" ;
	last ;

    } elsif ($res == CONFIRM_SKIP_FILE) {
	print "  Skipping this file...\n" ;
	next ;

    } elsif ($res == CONFIRM_TAG) {
	# actually tagging
	tag_with_values $file, $backend, $current_values
	    unless $self->{no_tagging_opt} ;
    }

    # sanity check
    die "Unknown confirm menu return value: $res.\n"
	unless $res == CONFIRM_TAG or $res == CONFIRM_DONT_TAG ;

    # renaming
    if (defined $self->{rename_opt}) {
	my $extension = $backend->{extension} ;
	Lltag::Rename::rename_with_values ($self, $file, $extension, $current_values) ;
    }
}

#############################################
# generate configuration file

sub generate_config {
    my $file = shift ;
    die "Cannot generate $file which already exists."
	if -e "$file" ;
    open NEWCFG, ">$file"
	or die "Cannot open $file ($!).\n" ;

    print NEWCFG "# This is a lltag configuration file.\n" ;
    print NEWCFG "# It was automatically generated.\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;

    map { print NEWCFG "format = \"$_\"\n" ; } @{$self->{user_format_strings}} ;

    print NEWCFG "guess = $self->{guess_opt}\n" ;
    print NEWCFG "edit = $self->{edit_opt}\n" ;
    print NEWCFG "no_path = $self->{no_path_opt}\n" ;

    map { print NEWCFG "default_$_ = \"$self->{field_default}{$_}\"\n" ; } (keys %{$self->{field_default}}) ;

    map { print NEWCFG "tag = \"$_\"\n" ; } @{$self->{additional_tags}} ;

    print NEWCFG "spaces = $self->{spaces_opt}\n" ;
    print NEWCFG "maj = $self->{maj_opt}\n" ;
    print NEWCFG "sep = \"$self->{sep_opt}\"\n"
	if defined $self->{sep_opt} ;
    map { print NEWCFG "regexp = \"$_\"\n" ; } @{$self->{regexp_opts}} ;
    print NEWCFG "type = ". (defined $self->{type_opt} ? $self->{type_opt} : "none") ."\n" ;
    print NEWCFG "clear_tags = $self->{clear_opt}\n" ;
    print NEWCFG "append_tags = $self->{append_opt}\n" ;
    print NEWCFG "no_tagging = $self->{no_tagging_opt}\n" ;

    print NEWCFG "rename_format = \"" .($self->{rename_opt} ? $self->{rename_opt} : ""). "\"\n" ;
    print NEWCFG "rename_min = $self->{rename_min_opt}\n" ;
    print NEWCFG "rename_sep = \"$self->{rename_sep_opt}\"\n" ;
    map { print NEWCFG "rename_regexp = \"$_\"\n" ; } @{$self->{rename_regexp_opts}} ;
    print NEWCFG "rename_ext = $self->{rename_ext_opt}\n" ;

    print NEWCFG "cddb = $self->{cddb_opt}\n" ;
    print NEWCFG "cddb_server_name = \"$self->{cddb_server_name}\"\n" ;
    print NEWCFG "cddb_server_port = $self->{cddb_server_port}\n" ;

    print NEWCFG "dry_run = $self->{dry_run_opt}\n" ;
    print NEWCFG "yes = $self->{yes_opt}\n" ;
    print NEWCFG "ask = $self->{ask_opt}\n" ;
    print NEWCFG "recursive = $self->{recursive_opt}\n" ;
    print NEWCFG "verbose = $verbose_level\n" ;

    close NEWCFG ;
}

generate_config $self->{gencfg_file}
    if defined $self->{gencfg_file} ;

Lltag::Misc::exit_readline () ;
