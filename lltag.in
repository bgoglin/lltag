#!/usr/bin/perl -w

use strict ;
no strict "refs" ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

use Term::ReadLine;

#######################################################
# configuration file location
my $common_lltag_dir = "@SYSCONFDIR@/lltag" ;
my $user_lltag_dir = "$ENV{HOME}/.lltag" ;
my $lltag_format_filename = "formats" ;
my $lltag_config_filename = "config" ;
my $lltag_edit_history_filename = "edit_history" ;

#######################################################
# configure readline depending on the features provided by the installation

my $term = Term::ReadLine->new('lltag editor');
my $attribs = $term->Attribs;
$term->ornaments('md,me,,');

# read the history file
eval {
    if (-f $user_lltag_dir."/".$lltag_edit_history_filename) {
	$term->ReadHistory ($user_lltag_dir."/".$lltag_edit_history_filename)
	    or warn "Failed to open history file $user_lltag_dir/$lltag_edit_history_filename: $!\n" ;
    }
} unless $term->Features->{ReadHistory} ;

my $readline_firsttime = 1 ;

sub dummy_readline {
    my $indent = shift ;
    my $prompt = shift ;
    my $preput = shift ;
    my $clear_allowed = shift ;
    $preput = "" if not defined $preput ;
    print $indent."The current value is given in parenthesis, <ENTER> to keep it"
	. ($clear_allowed ? ", <CLEAR> to clear it" : "")
	. ".\n"
	if $readline_firsttime ;
    $readline_firsttime = 0 ;
  ASK:
    my $val = $term->readline ("$indent$prompt ($preput) ? ") ;
    return $preput if !$val ;
    $val = "" if $val eq "CLEAR" or $val eq "<CLEAR>" ;
    if (!$val and !$clear_allowed) {
	print "$indent  Clearing is not allowed here.\n" ;
	goto ASK ;
    }
    return $val ;
}

sub real_readline {
  my $indent = shift ;
  my $prompt = shift ;
  my $preput = shift ;
  my $clear_allowed = shift ;
  $preput = "" if not defined $preput ;
 ASK:
  my $val = $term->readline ("$indent$prompt ? ", $preput) ;
  if (!$val and !$clear_allowed) {
      print "$indent  Clearing is not allowed here.\n" ;
      goto ASK ;
  }
  return $val ;
}

my $myreadline ;
if ($term->Features->{preput}) {
    $myreadline = \&real_readline ;
} else {
    $myreadline = \&dummy_readline ;
}

#######################################################
# format parameters
# (%a = artist, %t = title, %A = album, %n = number, %g = genre, %y = year, %c = comment)

my @field_names = ('artist', 'title', 'album', 'number', 'genre', 'year', 'comment') ;
my @field_letters = ('a', 't', 'A', 'n', 'g', 'y', 'c') ;

my %field_name_letter =
    (
     'artist' => 'a',
     'title' => 't',
     'album' => 'A',
     'number' => 'n',
     'genre' => 'g',
     'year' => 'y',
     'comment' => 'c',
     ) ;

my %field_name_trailing_spaces =
    (
     'artist' => '  ',
     'title' => '   ',
     'album' => '   ',
     'number' => '  ',
     'genre' => '   ',
     'year' => '    ',
     'comment' => ' ',
     ) ;

my %field_default = () ;

my %field_letter_name =
    (
     'a' => 'artist',
     't' => 'title',
     'A' => 'album',
     'n' => 'number',
     'g' => 'genre',
     'y' => 'year',
     'c' => 'comment',
     ) ;

#######################################################
# version
my $version = "@VERSION@" ;

sub version {
    print "This is lltag version $version.\n" ;
    exit 0 ;
}

#######################################################
# usage
sub usage {
    print $0." $version is a frontend to tag MP3/OGG/FLAC files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print " Tagging options:\n" ;
    print "  -F, --format <format>  Try format (multiple instances allowed)\n" ;
    print "  -G, --guess            Guess format (default)\n" ;
    print "  -p, --nopath           Remove the path from filenames when matching\n" ;
    print map { "  -". $field_name_letter{$_} .", --". $_.$field_name_trailing_spaces{$_}
		    ."<val>    Set the default value for ". ucfirst($_) ."\n" } @field_names ;
    print "  --spaces               Allow no or multiple spaces\n" ;
    print "  --maj                  Upcase first letters of words in tags\n" ;
    print "  --sep <s1|s2|...>      Replace |-separated strings with space in tags\n" ;
    print "  --regexp <regexp>      Apply a replace regexp to tags before tagging\n" ;
    print "  --mp3/--ogg/--flac     Force mp3, ogg of flac instead of by-extension detection\n" ;
    print "  --clear                Clear all tags of audio files when possible\n" ;
    print "  --append               Append tags only instead of replacing old ones when possible\n" ;
    print "  --no-tagging           Do not actually tag files\n" ;
    print " Renaming options:\n" ;
    print "  --rename <format>      Rename file according to format\n" ;
    print "  --rename-min           Lowcase tags before renaming\n" ;
    print "  --rename-sep <s>       Replace space with s in tags before renaming\n" ;
    print "  --rename-regexp <reg>  Apply a replace regexp to tags before renaming\n" ;
    print "  --rename-ext           Assume the rename format provides an extension\n" ;
    print " General options:\n" ;
    print "  --dry-run              Do nothing but show what would have been done\n" ;
    print "  --yes                  Tag without asking for confirmation when guessing\n" ;
    print "                         Rename without asking for confirmation\n" ;
    print "  --ask                  Always ask for confirmation before tagging\n" ;
    print "  -R, --recursive        Recursively search all files in subdirectories\n" ;
    print "  -v, --verbose          Verbose messages\n" ;
    print "  --config <file>        Read additional configuration file\n" ;
    print "  --gencfg <file>        Generate additional configuration file\n" ;
    print " Behavior options:\n" ;
    print "  -S                     Show all tags from files\n" ;
    print "  --show-tags <tag,..>   Show several tags from files\n" ;
    print "  -L, --list             List internal formats\n" ;
    print "  -V, --version          Show lltag version\n" ;
    print "  -h, --help             Show this help\n" ;
    print " Format is composed of anything you want with special fields:\n" ;
    print map { "  %". $field_name_letter{$_} ." means ". ucfirst($_) ."\n" } @field_names ;
    print "  %d means Dummy text\n" ;
    print "  %% means %\n" ;
    print "\n" ;
    print "Author:    Brice Goglin\n" ;
    print "Homepage:  http://home.gna.org/lltag\n" ;
    print "Report bugs to:  <lltag-users AT gna.org>\n" ;
    exit 1;
}

#######################################################
# globals

my $mp3_type = "mp3" ;
my $ogg_type = "ogg" ;
my $flac_type = "flac" ;

# subregexp
my $match_path = '(?:[^/]*\/)*' ;
my $match_any = '((?:[^ /]+ +)*[^ /]+)' ;
my $match_num = '([0-9]+)' ;
my $match_space = ' ';
my $match_spaces = ' *' ;
my $match_limit = '' ;

# the parser that the user wants to always use
my $preferred_parser = undef ;

#######################################################
# options

my $dry_run_opt = 0 ;
my $verbose_opt = 0 ;
my $recursive_opt = 0 ;
my $list_formats_opt = 0 ;
my $show_tags_opt = "" ;
my $no_tagging_opt = 0 ;

my $ask_opt = 0 ;
my $guess_opt = 0 ;
my $nopath_opt = 0 ;
my $maj_opt = 0 ;
my $sep_opt = undef ;
my $spaces_opt = 0 ;
my $type_opt = undef ;
my $yes_opt = 0 ;
my $default_opt = 0 ;
my $clear_opt = 0 ;
my $append_opt = 0 ;
my @regexp_opts = () ;

my $rename_opt = undef ;
my $rename_min_opt = 0 ;
my $rename_sep_opt = " " ;
my $rename_ext_opt = 0 ;
my @rename_regexp_opts = () ;

my $mp3_ext = "mp3" ;
my $ogg_ext = "ogg" ;
my $flac_ext = "flac" ;

my $gencfg_file = undef ;

# parsers
my @user_format_strings = () ;

#######################################################
# parse config files first

my @additional_config_files = () ;

# process these options but kept other options in @ARGV for later
Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'config=s'     => \@additional_config_files,
        ) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

sub process_option {
    $_ = shift ;
    chomp $_ ;
    if (/^format\s*=\s*"(.+)"$/) {
	push (@user_format_strings, $1) ;
    } elsif (/^guess\s*=\s*(.+)$/) {
	$guess_opt = $1 ;
    } elsif (/^nopath\s*=\s*(.+)$/) {
	$nopath_opt = $1 ;
    } elsif (/^default_([^ ]*)\s*=\s*"(.*)"$/) {
        die "Unrecognized option line #$.: \"$_\"\n"
	    unless defined $field_name_letter{$1} ;
	$field_default{$1} = $2 ;
    } elsif (/^spaces\s*=\s*(.+)$/) {
	$spaces_opt = $1 ;
    } elsif (/^maj\s*=\s*(.+)$/) {
	$maj_opt = $1 ;
    } elsif (/^sep\s*=\s*"(.*)"$/) {
	$sep_opt = $1 ;
    } elsif (/^type\s*=\s*(.+)$/) {
	if ($1 eq "none") {
	    $type_opt = undef ;
	} elsif ($1 ne $mp3_type and $1 ne $ogg_type and $1 ne $flac_type) {
	    die "Unrecognized type '$1' line #$\n" ;
	} else {
	    $type_opt = $1 ;
	}
    } elsif (/^regexp\s*=\s*"(.+)"$/) {
	push (@regexp_opts, $1) ;
    } elsif (/^clear_tags\s*=\s*(.+)$/) {
	$clear_opt = $1 ;
    } elsif (/^append_tags\s*=\s*(.+)$/) {
	$append_opt = $1 ;
    } elsif (/^no_tagging\s*=\s*(.+)$/) {
	$no_tagging_opt = $1 ;
    } elsif (/^rename_format\s*=\s*"(.*)"$/) {
	if ($1 eq "") {
	    $rename_opt = undef ;
	} else {
	    $rename_opt = $1 ;
	}
    } elsif (/^rename_min\s*=\s*(.+)$/) {
	$rename_min_opt = $1 ;
    } elsif (/^rename_sep\s*=\s*"(.*)"$/) {
	$rename_sep_opt = $1 ;
    } elsif (/^rename_regexp\s*=\s*"(.+)"$/) {
	push (@rename_regexp_opts, $1) ;
    } elsif (/^rename_ext\s*=\s*(.+)$/) {
	$rename_ext_opt = $1 ;
    } elsif (/^dry_run\s*=\s*(.+)$/) {
	$dry_run_opt = $1 ;
    } elsif (/^yes\s*=\s*(.+)$/) {
	$yes_opt = $1 ;
	$ask_opt = 0 if $1 ;
    } elsif (/^ask\s*=\s*(.+)$/) {
	$ask_opt = $1 ;
	$yes_opt = 0 if $1 ;
    } elsif (/^recursive\s*=\s*(.+)$/) {
	$recursive_opt = $1 ;
    } elsif (/^verbose\s*=\s*(.+)$/) {
	$verbose_opt = $1 ;
# Error
    } elsif (/^[^#]/ && !/^(\s*)$/) {
        die "Unrecognized option line #$.: \"$_\"\n" ;
    }
}

sub parse_generic_config_file {
    my $file = shift ;
    open CONF, $file
        or return ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

parse_generic_config_file "$common_lltag_dir/$lltag_config_filename" ;
parse_generic_config_file "$user_lltag_dir/$lltag_config_filename" ;

sub parse_additional_config_file {
    my $file = shift ;
    open CONF, $file
        or die "Failed to open additional configuration file '$file' ($!).\n" ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

foreach my $file (@additional_config_files) {
    parse_additional_config_file $file ;
}

#######################################################
# parse cmdline options

# parse options
GetOptions(
	   'F|format=s'   => \@user_format_strings,
	   'G|guess'      => \$guess_opt,
	   'p|nopath'     => \$nopath_opt,
	   'spaces'       => \$spaces_opt,
	   'maj'          => \$maj_opt,
	   'sep=s'        => \$sep_opt,
	   'regexp=s'     => \@regexp_opts,
	   'mp3'          => sub { $type_opt = $mp3_type ; },
	   'ogg'          => sub { $type_opt = $ogg_type ; },
	   'flac'         => sub { $type_opt = $flac_type ; },
	   'clear'        => \$clear_opt,
	   'append'       => \$append_opt,
	   'no-tagging'   => \$no_tagging_opt,
	   'rename=s'     => \$rename_opt,
	   'rename-min'   => \$rename_min_opt,
	   'rename-sep=s' => \$rename_sep_opt,
	   'rename-regexp=s' => \@rename_regexp_opts,
	   'rename-ext'   => \$rename_ext_opt,
	   'dry-run'      => \$dry_run_opt,
	   'R|recursive'  => \$recursive_opt,
	   'yes'          => sub { $yes_opt = 1 ; $ask_opt = 0 ; },
	   'ask'          => sub { $ask_opt = 1 ; $yes_opt = 0 ; },
	   'v|verbose'    => \$verbose_opt,
	   'gencfg=s'     => \$gencfg_file,
	   'h|help'       => sub { usage () ; },
	   'V|version'    => sub { version () ; },
	   'L|list'       => \$list_formats_opt,
	   'show-tags=s'  => \$show_tags_opt,
	   'S'            => sub { $show_tags_opt = "all" ; },
	   map { my $field = $_ ;
		 $field_name_letter{$field} .'|'. $field .'=s'
		     => sub { shift ; $field_default{$field} = shift ; $default_opt = 1 ; },
	       } @field_names ,
	   ) or usage () ;

# yes/ask option status may vary with user confirmation replies
my $current_yes_opt = $yes_opt ;
my $current_ask_opt = $ask_opt ;

# confirmation when renaming
my $current_rename_yes_opt = $yes_opt ;

# spaces_opt changes matching regexps
$match_limit = $match_space = $match_spaces if $spaces_opt ;

# if no parsers and no guess, force guess
$guess_opt = 1 unless @user_format_strings or $default_opt or $list_formats_opt ;

# forward declarations
sub apply_parser ;

#######################################################
# Tagging return values
my $TAG_SUCCESS_PREFERRED = 1 ;
my $TAG_SUCCESS = 0 ;
my $TAG_SKIP_FILE = -1 ;
my $TAG_SKIP_PARSER = -2 ;
my $TAG_SKIP_PATH_PARSER = -3 ;
my $TAG_NO_MATCH = -4 ;

#######################################################
# Tagging acceptable behavior
my $TAG_MAY_SKIP_PARSER = 1 ;
my $TAG_MAY_SKIP_PATH_PARSER = 2 ;
my $TAG_MAY_PREFER = 4 ;

#######################################################
# rewrite of system which returns a descriptor of a stream
# containing both stdout and stderr
sub system_with_output {
    pipe (my $pipe_out, my $pipe_in) ;
    my $pid = fork() ;
    if ($pid < 0) {
	# in the father, when fork failed
	close $pipe_in ;
	close $pipe_out ;
	return (-1, "Failed to fork to execute command line: ". join (" ", @_) ."\n") ;
    } elsif ($pid > 0) {
	# in the father, when fork done
	close $pipe_in ;
	waitpid($pid, 0);
	my $status = $? >> 8 ;
	$status = -1
	    if $status == 255 ;
	my @lines = <$pipe_out> ;
	close $pipe_out ;
	return ( $status , @lines ) ;
    } else {
	# in the child
	close $pipe_out ;
	open STDERR, ">&", $pipe_in ;
	open STDOUT, ">&", $pipe_in ;
	{ exec @_ } ;
	print $pipe_in "Failed to execute command line: ". join (" ", @_) ."\n" ;
	print $pipe_in "Please install $_[0] properly (see README).\n"
	    if $!{ENOENT} or $!{EPERM} ;
	close $pipe_in ;
	exit -1 ;
    }
}

#######################################################
# extract file type and parsename

sub extract_parsename_and_type {
    my $file = shift ;

    # split into parsename and extension, and remove the path if asked
    my @parts = split (/\./, $file) ;
    my $extension = pop @parts ;
    my $parsename = join (".", @parts) ;
    if ($nopath_opt) {
	my @parts = split (/\//, $parsename) ;
	$parsename = pop @parts ;
    }

    my $file_type = $type_opt ;
    if (not defined $type_opt) {
    # if not forced, get the type from the extension
	if ($extension =~ /$mp3_ext/i) {
	    $file_type = $mp3_type ;
	} elsif ($extension =~ /$ogg_ext/i) {
	    $file_type = $ogg_type ;
	} elsif ($extension =~ /$flac_ext/i) {
	    $file_type = $flac_type ;
	}
    }

    return ($parsename, $file_type) ;
}

 #######################################################
# handle hashes of tags

# add a value to a field, creating an array if required
sub append_tag_value {
    my $values = shift ;
    my $field = shift ;
    my $value = shift ;
    if (not defined $values->{$field}) {
	$values->{$field} = $value ;
    } elsif (ref($values->{$field}) ne 'ARRAY') {
	@{$values->{$field}} = ($values->{$field}, $value) ;
    } else {
	push @{$values->{$field}}, $value ;
    }
}

# append a set of unique values into and old hashes, depending of clear/append options
sub append_tag_values {
    my $old_values = shift ;
    my $new_values = shift ;

    if ($clear_opt) {
	$old_values = () ;
    }

    foreach my $field (keys %{$new_values}) {
	$old_values->{$field} = undef
	    if defined $old_values->{$field} and !$append_opt ;
	append_tag_value $old_values, $field, $new_values->{$field} ;
    }

    return $old_values ;
}


# return values for a field as an array
sub get_tag_value_array {
    my $values = shift ;
    my $field = shift ;
    if (not defined $values->{$field}) {
	return () ;
    } elsif (ref ($values->{$field}) eq 'ARRAY') {
	return @{$values->{$field}} ;
    } else {
	return ($values->{$field}) ;
    }
}

# return a unique value for a field
sub get_tag_unique_value {
    my $values = shift ;
    my $field = shift ;
    my @array = get_tag_value_array $values, $field ;
    die "Trying to return a unique tag value on an empty array.\n"
	if ! @array ;
    return $array[0] ;
}

# return non-regular keys whose value is defined
sub get_values_non_regular_keys {
    my $values = shift ;
    return grep {
	my $key = $_ ;
	!(grep { $_ eq $key } @field_names)
    } (keys %{$values}) ;
}

#######################################################
# show existing tags if --show-tags was passed

sub mp3_read_tags {
    my $file = shift ;
    my ($status, @output) = system_with_output
	("mp3info", "-p", "Artist=%a\nAlbum=%l\nTitle=%t\nNumber=%n\nGenre=%g\nYear=%y\nComment=%c\n", $file) ;
    return ($status)
	if $status ;
    return ($status, @output) ;
}

sub ogg_read_tags {
    my $file = shift ;
    my ($status, @output) = system_with_output
	("vorbiscomment", "-l", $file) ;
    return ($status)
	if $status ;
    return ($status, @output) ;
}

sub flac_read_tags {
    my $file = shift ;
    my ($status, @output) = system_with_output
	("metaflac", "--list", "--block-type=VORBIS_COMMENT", $file) ;
    return ($status)
	if $status ;
    @output = map { my $line =$_ ; $line =~ s/^\s*comment\[\d+\]\s*:\s*(.*)/$1/ ; $line } ( grep { /comment\[\d+\]/ } @output ) ;
    return ($status, @output) ;
}

sub read_tags {
    my $file = shift ;
    my $file_type = shift ;

    # extract tags as a stream
    my $status ;
    my @output ;
    if ($file_type eq $mp3_type) {
	($status, @output) = mp3_read_tags $file ;
    } elsif ($file_type eq $ogg_type) {
	($status, @output) = ogg_read_tags $file ;
    } elsif ($file_type eq $flac_type) {
	($status, @output) = flac_read_tags $file ;
    }
    if ($status) {
	print "  Failed to get tags from file.\n" ;
	next ;
    }

    # extract tags from the stream
    my $values = {} ;
    while (my $line = shift @output) {
	chomp $line ;
	$line =~ s/^tracknumber=/number=/i ;
	my ($field, $value) = ($line =~ /^(.*)=(.*)$/) ;
	next if !$value ;
	append_tag_value $values, (lc $field), $value ;
    }

    return $values ;
}

#######################################################
# apply user-given regexp

sub apply_regexp_to_tag {
    my $val = shift ;
    my $regexp = shift ;
    my $tag = shift ;

    # parse the regexp
    if ($regexp =~ /(?:([^:]+):)?s\/([^\/]+)\/([^\/]*)\/$/) {
	my @tags = () ;
	@tags = split (/,/, $1) if $1;
	my $from = $2 ;
	my $to = $3 ;
	$val =~ s/$from/$to/g
	    if !@tags or grep { $tag eq $_ } @tags ;
    } else {
	die "Unrecognized user regexp '$regexp'.\n" ;
    }

    return $val ;
}

#######################################################
# internal parsers

my @internal_basename_parsers = () ;
my @internal_path_parsers = () ;

sub read_internal_parsers {
    # get parsers from configuration files
    my $file ;
    if (open FORMAT, "$user_lltag_dir/$lltag_format_filename") {
	$file = "$user_lltag_dir/$lltag_format_filename" ;
    } elsif (open FORMAT, "$common_lltag_dir/$lltag_format_filename") {
	$file = "$common_lltag_dir/$lltag_format_filename" ;
    } else {
	print "Did not find any format file.\n" ;
	goto NO_FORMATS_FILE_FOUND;
    }
    print "Reading format file '$file'...\n" if $verbose_opt ;

    my $type = undef ;
    my $title = undef ;
    my $regexp = undef ;
    my @field_table = () ;

    while (<FORMAT>) {
	chomp $_ ;
	next if /^#/ ;
	next if /^$/ ;
	if (/^\[(.*)\]$/) {
	    if ($type and $title and $regexp and @field_table) {
		my $parser ;
		$parser->{title} = $title ;
		$parser->{regexp} = $regexp ;
		@{$parser->{field_table}} = @field_table ;
		if ($type eq "basename" or $type eq "filename") {
		    # TODO: drop filename support on september 11 2006
		    print "  Got basename format '$title'\n" if $verbose_opt ;
		    push (@internal_basename_parsers, $parser) ;
		} elsif ($type eq "path") {
		    print "  Got path format '$title'\n" if $verbose_opt ;
		    push (@internal_path_parsers, $parser) ;
		}
	    } elsif ($type or $title or $regexp or @field_table) {
		die "Incomplete format at line $. in file '$file'\n" ;
	    }
	    $type = undef ; $regexp = undef ; @field_table = () ;
	    $title = $1 ;
	    # stocker la ligne ?
	} elsif (/^type = (.*)$/) {
	    die "Unsupported format type '$1' at line $. in file '$file'\n"
		if $1 ne "basename" and $1 ne "filename" and $1 ne "path" ;
	    # TODO: drop filename support on september 11 2006
	    $type = $1 ;
	} elsif (/^regexp = (.*)$/) {
	    $regexp = $1 ;
	    $regexp =~ s/\./\\./g ;
	    $regexp =~ s/\)/\\\)/g ;
	    $regexp =~ s@/@\\/@g ;
	    # do the replacement progressively so that %% and %x and not mixed
	    while ($regexp =~ m/(%(?:P|L|S|N|A|%))/) {
		if ($1 eq '%P') {
		    $regexp =~ s/%P/$match_path/ ;
		} elsif ($1 eq '%L') {
		    $regexp =~ s/%L/$match_limit/ ;
		} elsif ($1 eq '%S') {
		    $regexp =~ s/%S/$match_space/ ;
		} elsif ($1 eq '%N') {
		    $regexp =~ s/%N/$match_num/ ;
		} elsif ($1 eq '%A') {
		    $regexp =~ s/%A/$match_any/ ;
		} elsif ($1 eq '%%') {
		    $regexp =~ s/%%/%/ ;
		}
	    }
	} elsif (/^indices = (.*)$/) {
	    @field_table = map {
		my $field ;
		if (defined $field_letter_name{$_}) {
		    $field = $field_letter_name{$_} ;
		} elsif ($_ eq 'd') {
		    $field = '' ;
		} else {
		    die "Unrecognized field letter '$_' on line $. in file '$file'\n" ;
		}
		$field } split (/,/, $1) ;
	} else {
	    die "Unrecognized line $. in file '$file': '$_'\n" ;
	}
    }
    close FORMAT ;

    # save the last format
    if ($type and $title and $regexp and @field_table) {
	my $parser ;
	$parser->{title} = $title ;
	$parser->{regexp} = $regexp ;
	@{$parser->{field_table}} = @field_table ;
	if ($type eq "basename" or $type eq "filename") {
		    # TODO: drop filename support on september 11 2006
	    print "  Got basename format '$title'\n" if $verbose_opt ;
	    push (@internal_basename_parsers, $parser) ;
	} elsif ($type eq "path") {
	    print "  Got path format '$title'\n" if $verbose_opt ;
	    push (@internal_path_parsers, $parser) ;
	}
    } elsif ($type or $title or $regexp or @field_table) {
	die "Incomplete format at line $. in file '$file'\n" ;
    }
  NO_FORMATS_FILE_FOUND:
}

sub apply_internal_basename_parsers {
    my $file = shift ;
    my $parsename = shift ;
    my $file_type = shift ;

    # no path, only try each basename parser
    foreach my $basename_parser (@internal_basename_parsers) {
	# try to tag, with confirmation
	my ($res, $values) = apply_parser $file, $parsename, $file_type, $basename_parser, 1, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER ;
	if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERRED || $res == $TAG_SKIP_FILE) {
	    if ($res == $TAG_SUCCESS_PREFERRED) {
		$preferred_parser = $basename_parser ;
	    }
	    return ($res, $values) ;
	}
	# try next parser
	die "Unknown tag return value: $res\n" if $res != $TAG_SKIP_PARSER ;
    }
    return ($TAG_NO_MATCH, undef) ;
}

sub merge_internal_parsers {
    my $path_parser = shift ;
    my $basename_parser = shift ;
    my $parser ;
    $parser->{title} = "$path_parser->{title}/$basename_parser->{title}" ;
    $parser->{regexp} = "$path_parser->{regexp}/$basename_parser->{regexp}" ;
    @{$parser->{field_table}} = (@{$path_parser->{field_table}}, @{$basename_parser->{field_table}}) ;
    return $parser ;
}

sub apply_internal_path_basename_parsers {
    my $file = shift ;
    my $parsename = shift ;
    my $file_type = shift ;

    # try each path parser and each basename parser
    foreach my $path_parser (@internal_path_parsers) {
	if ($parsename =~ /^$path_parser->{regexp}\/[^\/]+$/) {
	    foreach my $basename_parser (@internal_basename_parsers) {
		my $whole_parser = merge_internal_parsers ($path_parser, $basename_parser) ;
		# try to tag, with confirmation
		my ($res, $values) = apply_parser $file, $parsename, $file_type, $whole_parser, 1, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER|$TAG_MAY_SKIP_PATH_PARSER ;
		if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERRED || $res == $TAG_SKIP_FILE) {
		    if ($res == $TAG_SUCCESS_PREFERRED) {
			$preferred_parser = $whole_parser ;
		    }
		    return ($res, $values) ;
		}
		# try next path parser if asked
		goto NEXT_PATH_PARSER
		    if $res == $TAG_SKIP_PATH_PARSER ;

		# try next parser
		die "Unknown tag return value: $res\n" if $res != $TAG_SKIP_PARSER ;
	    }
	}
      NEXT_PATH_PARSER:
    }
    return ($TAG_NO_MATCH, undef) ;
}

#######################################################
# user parsers

# list of user-provided parsers
my @user_parsers ;

# change format names into a parsing string
my $field_letters_union = (join '|', @field_letters) ;

# change a format strings into usable infos
sub generate_user_parser {
    my $format_string = shift ;

    print "Generating parser for format '". $format_string ."'...\n" ;

    my $parser ;
    $parser->{title} = $format_string ;

    # merge spaces if --spaces was passed
    if ($spaces_opt) {
	$format_string =~ s/ +/ /g ;
    }

    # create the regexp and store indice fields
    my @array = split(//, $format_string) ;
    my @field_table = () ;
    for(my $i = 0; $i < @array - 1; $i++) {

	my $char = $array[$i] ;
	# normal characters
	if ($char ne "%") {

	    if ($char eq " ") {
		# replace spaces with general space matching regexp
		$array[$i] = $match_space ;

	    } elsif ($char eq "/") {
		# replace / with space flexible matching regexp
		$array[$i] = $match_limit."/".$match_limit ;

	    } elsif (index ("()[]", $char) != -1) {
		# escape regexp control characters
		$array[$i] = "\\".$char ;

	    }
	    # keep this character
	    next ;
	}

	# remove % and check next char
	splice (@array, $i, 1) ;
	# replace the char with the matching
	$char = $array[$i] ;
	next if $char eq "%" ;
	if ($array[$i] eq "n") {
	    $array[$i] = $match_num ;
	} elsif ($array[$i] =~ /$field_letters_union|d/) {
	    $array[$i] = $match_any ;
	} else {
	    die "  ERROR: Format '". $format_string ."' contains unrecognized operator '%". $array[$i] ."'.\n" ;
	}
	# store the indice
	if ($char eq "d") {
	    push @field_table, '' ;
	} else {
	    push @field_table, $field_letter_name{$char} ;
	}
    }
    @{$parser->{field_table}} = @field_table ;

    # done
    if ($spaces_opt) {
	$parser->{regexp} = $match_limit. join("", @array) .$match_limit ;
    } else {
	$parser->{regexp} = join("", @array) ;
    }

    # check insolvable regexp
    for(my $i = 0; $i < @array - 1; $i++) {
	my $char = $array[$i] ;
	my $nextchar = $array[$i+1] ;
	if ( $char eq $match_any and
	     ( $nextchar eq $match_any or $nextchar eq $match_num ) ) {
	    print "  WARNING: Format '". $format_string
		."' leads to problematic subregexp '". $char.$nextchar
		."' that won't probably match as desired.\n" ;
	}
    }

    if ($verbose_opt) {
	print "  Format string will parse with: ". $parser->{regexp} ."\n" ;
	print "    Fields are: ". (join ',', @field_table) ."\n" ;
    }

    return $parser ;
}

sub generate_user_parsers {
    @user_parsers = map ( generate_user_parser ($_), @user_format_strings ) ;
}

sub apply_user_parsers {
    my $file = shift ;
    my $parsename = shift ;
    my $file_type = shift ;

    # try each format until one works
    foreach my $parser (@user_parsers) {
	# try to tag, without confirmation
	my ($res, $values) = apply_parser $file, $parsename, $file_type, $parser, 0, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER ;
	if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERRED || $res == $TAG_SKIP_FILE) {
	    if ($res == $TAG_SUCCESS_PREFERRED) {
		$preferred_parser = $parser ;
	    }
	    return ($res, $values) ;
	}
	print "    '". $parser->{title} ."' does not match.\n" ;
	# try next parser
	die "Unknown tag return value: $res.\n" if $res != $TAG_SKIP_PARSER ;
    }
    return ($TAG_NO_MATCH, undef) ;
}

#######################################################
# parsing confirmation

sub tags_confirm_letters {
    my $behaviors = shift ;
    my $string = "[<y>v" ;
    $string .= "u" if $behaviors & $TAG_MAY_PREFER ;
    $string .= "ae" ;
    $string .= "n" if $behaviors & $TAG_MAY_SKIP_PARSER ;
    $string .= "p" if $behaviors & $TAG_MAY_SKIP_PATH_PARSER ;
    $string .= "s,(h)elp]" ;
    return $string ;
}

sub tags_confirm_usage {
    my $behaviors = shift ;
    print "    y => Yes, use this matching (default)\n" ;
    print "    v => View which fields were matched\n" ;
    print "    u => Use this format for all files until one does not match\n"
	if $behaviors & $TAG_MAY_PREFER ;
    print "    a => Always yes, stop asking for a confirmation\n" ;
    print "    e => Edit these fields by hand\n" ;
    print "    n => No, try the next matching format\n"
	if $behaviors & $TAG_MAY_SKIP_PARSER ;
    print "    p => No, try the next path matching format\n"
	if $behaviors & $TAG_MAY_SKIP_PATH_PARSER ;
    print "    s => Skip this file, don't process it\n" ;
    print "    h => Show this help\n" ;
}

sub tags_confirm_fields {
    my $file = shift ;
    my $file_type = shift ;
    my $confirm = shift ;
    my $behaviors = shift ;
    my $values = shift ;

    # prefer this type of tagging ?
    my $preferred = 0 ;

    # are we only tagging default values ?
    my $only_defaults = 0 ;
    if (not defined $values) {
	$values = () ;
	$only_defaults = 1 ;
    }

    # add defaults
    foreach my $field (@field_names) {
	$values->{$field} = $field_default{$field} if not defined $values->{$field} and defined $field_default{$field} ;
    }

    # is there something to do ?
    my $nothing_to_do = (scalar (keys %{$values}) == 0) ;

    # confirm if required
    if ($current_ask_opt or ($confirm and !$current_yes_opt)) {
      ASK_CONFIRM:
	print "  ".
	    ($nothing_to_do ? "Do not change any tag"
	     : ($only_defaults ? "Apply defaults"
		: "Use this matching"))
	    ." ".(tags_confirm_letters ($behaviors))." ? " ;
	my $reply = <> ;
	chomp $reply ;
	if ($reply eq "" or $reply =~ /^y/i) {
	    goto OK ;
	} elsif ($reply eq "v") {
	    foreach my $field (@field_names) {
		print "    ".ucfirst($field).$field_name_trailing_spaces{$field}.": ".$values->{$field}."\n"
		    if defined $values->{$field} ;
	    }
	    # TODO: show other fields ? not possible until we edit existing tags
	    goto ASK_CONFIRM ;
	} elsif ($reply =~ /^a/i) {
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto OK ;
	} elsif ($behaviors & $TAG_MAY_PREFER and $reply =~ /^u/i) {
	    $preferred = 1 ;
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto OK ;
	} elsif ($behaviors & $TAG_MAY_SKIP_PARSER and $reply =~ /^n/i) {
	    return ($TAG_SKIP_PARSER, undef) ;
	} elsif ($behaviors & $TAG_MAY_SKIP_PATH_PARSER and $reply =~ /^p/i) {
	    return ($TAG_SKIP_PATH_PARSER, undef) ;
	} elsif ($reply =~ /^s/i) {
	    return ($TAG_SKIP_FILE, undef) ;
	} elsif ($reply =~ /^e/i) {

	    my $edit_values = {} ;
	    foreach (keys %{$values}) { $edit_values->{$_} = $values->{$_} } ;
	  ASK_EDIT:
	    print "    Edit a field [atAngycEC,<h>elp] ? " ;
	    my $edit_reply = <> ;
	    chomp $edit_reply ;
	    if ($edit_reply =~ /^($field_letters_union)$/) {
		my $field = $field_letter_name{$edit_reply} ;
		$edit_values->{$field} = &$myreadline ("      ", ucfirst($field)." field", $edit_values->{$field}, 1) ;
		goto ASK_EDIT ;
	    } elsif ($edit_reply eq "E") {
		$values = $edit_values ;
		goto OK ;
	    } elsif ($edit_reply eq "C") {
		goto ASK_CONFIRM ;
	    } else {
		# print all fields, including the undefined ones
		foreach my $field (@field_names) {
		    my $val = $edit_values->{$field} ;
		    if (not defined $val) {
			$val = "<not defined>" ;
		    } elsif ($val eq "") {
			$val = "<CLEAR>" ;
		    } else {
			$val = "'".$val."'" ;
		    }
		    print "      ".$field_name_letter{$field}
		    ." => Edit ".ucfirst($field).$field_name_trailing_spaces{$field}
			." (=".$val.")\n" ;
		}
		# TODO: show other fields ? not possible until we edit existing tags
		print "      E => End edition and process the file\n" ;
		print "      C => Cancel edition\n" ;
		goto ASK_EDIT ;
	    }

	} else {
	    tags_confirm_usage $behaviors ;
	    goto ASK_CONFIRM ;
	}
    }

  OK:
    if ($preferred) {
	return ($TAG_SUCCESS_PREFERRED, $values) ;
    } else {
	return ($TAG_SUCCESS, $values) ;
    }
}

sub apply_parser {
    my $file = shift ;
    my $parsename = shift ;
    my $file_type = shift ;
    my $parser = shift ;
    my $confirm = shift ;
    my $behaviors = shift ;

    if ($parsename =~ /^$parser->{regexp}$/) {
	print "    '$parser->{title}' matches this file...\n" ;

	my @field_table = @{$parser->{field_table}} ;
	my $values = {} ;
	my $i = 1 ;

	# traverse matched values (stored in ${$i}
	while ( $i <= @field_table ) {
	    my $field = $field_table[$i-1] ;
	    if ($field) { # to discard '' (for dummy)
		my $val = ${$i} ;
		$val =~ s/\b(.)/uc $1/eg if $maj_opt ;
		$val =~ s/($sep_opt)/ /g if defined $sep_opt ;
		map { $val = apply_regexp_to_tag ($val, $_, $field) } @regexp_opts ;
		if (defined $values->{$field}) {
		    print "    WARNING: ".ucfirst($field)." already set to '".$values->{$field}
		    ."', skipping new value '$val'.\n" if defined $values->{$field} and $values->{$field} ne $val ;
		    goto NEXT_FIELD ;
		}
		$values->{$field} = $val ;
		if ($verbose_opt or $confirm or $current_ask_opt) {
		    print "    ". ucfirst($field)
			.$field_name_trailing_spaces{$field}
		    .": ". $val ."\n" ;
		}
	    }
	  NEXT_FIELD:
	    $i++ ;
	}

	return tags_confirm_fields ($file, $file_type, $confirm, $behaviors, $values) ;
    } else {
	return ($TAG_SKIP_PARSER, undef) ;
    }
}

sub try_to_parse {
    my $file = shift ;
    my $parsename = shift ;
    my $file_type = shift ;

    my $values = undef ;
    my $res ;

    # try the preferred parser first
    if (defined $preferred_parser) {
	print "  with the previous matching parser...\n" ;
	# there can't be any confirmation here, SKIP is not possible
	($res, $values) = apply_parser $file, $parsename, $file_type, $preferred_parser, 0, 0 ;
	if ($res != $TAG_SKIP_PARSER) {
	    # only SUCCESS if possible
	    die "Unknown tag return value: $res.\n"
		if $res != $TAG_SUCCESS ;
	    return ($res, $values) ;
	} else {
	    print "    '$preferred_parser->{title}' does not match anymore, returning to original mode\n" ;
	    $current_ask_opt = $ask_opt ; $current_yes_opt = $yes_opt ;
	    $preferred_parser = undef ;
	}
    }

    # try user provided parsers then
    if (@user_parsers) {
	print "  with user-provided formats...\n" ;
	($res, $values) = apply_user_parsers $file, $parsename, $file_type ;
	return ($res, $values)
	    if $res == $TAG_SUCCESS or $res == $TAG_SUCCESS_PREFERRED or $res == $TAG_SKIP_FILE ;
    }

    # try to guess my internal format database then
    if ($guess_opt) {
	print "  with internal formats...\n" ;

	if ($nopath_opt or not ($parsename =~ /\//)) {
	    ($res, $values) = apply_internal_basename_parsers $file, $parsename, $file_type ;
	} else {
	    ($res, $values) = apply_internal_path_basename_parsers $file, $parsename, $file_type ;
	}
	return ($res, $values)
	    if $res == $TAG_SUCCESS or $res == $TAG_SUCCESS_PREFERRED or $res == $TAG_SKIP_FILE ;
    }

    if ($guess_opt or @user_parsers) {
	print "  Didn't find any parser!\n" ;
    }

    # tag with default values only
    ($res, $values) = tags_confirm_fields $file, $file_type, 1, 0, undef ;
    die "Unknown tag return value: $res.\n" if $res != $TAG_SUCCESS and $res != $TAG_SKIP_FILE ;
    return ($res, $values) ;
}

#######################################################
# real tagging

sub mp3_tagging_system_args {
    my $values = shift ;
    my %field_name_mp3info_option =
	(
	 'artist' => 'a',
	 'title' => 't',
	 'album' => 'l',
	 'number' => 'n',
	 'genre' => 'g',
	 'year' => 'y',
	 'comment' => 'c'
	 ) ;
    my @mp3_tagging_cmd = ( 'mp3info' ) ;
    my @mp3_tagging_clear_option = map { ( "-$_" , "" ) } (values %field_name_mp3info_option) ;

    return ( @mp3_tagging_cmd ,
	     # clear all tags
	     @mp3_tagging_clear_option ,
	     # apply new tags
	     ( map {
		 # only one tag is allowed, use the first one
		 ( "-".$field_name_mp3info_option{$_} , (get_tag_unique_value $values, $_) )
		 } @field_names
	       ),
	     # TODO: drop other fields
	     ) ;
}

sub ogg_tagging_system_args {
    my $values = shift ;
    my %field_name_vorbiscomment_option =
	(
	 'artist' => 'ARTIST',
	 'title' => 'TITLE',
	 'album' => 'ALBUM',
	 'number' => 'TRACKNUMBER',
	 'genre' => 'GENRE',
	 'date' => 'DATE',
	 'comment' => 'COMMENT'
	 ) ;
    my @ogg_tagging_cmd = ( 'vorbiscomment', '-q' ) ;
    my @ogg_tagging_clear_option = ( '-w' ) ;

    return ( @ogg_tagging_cmd ,
	     # clear all tags
	     @ogg_tagging_clear_option ,
	     # apply new tags
	     ( map {
		 my $option = $field_name_vorbiscomment_option{$_} ;
		 my @tags = get_tag_value_array $values, $_ ;
		 map { ( "-t" , $option."=".$_ ) } @tags
		 } @field_names
	       ),
	     # TODO: handle other fields
	     ) ;
}

sub flac_tagging_system_args {
    my $values = shift ;
    my %field_name_metaflac_option =
	(
	 'artist' => 'ARTIST',
	 'title' => 'TITLE',
	 'album' => 'ALBUM',
	 'number' => 'TRACKNUMBER',
	 'genre' => 'GENRE',
	 'year' => 'DATE',
	 'comment' => 'COMMENT'
	 ) ;
    my @flac_tagging_cmd = ( 'metaflac' ) ;
    my @flac_tagging_clear_option = ( '--remove-all-tags' ) ;

    return ( @flac_tagging_cmd ,
	     # clear all tags
	     @flac_tagging_clear_option ,
	     # apply new tags
	     ( map {
		 my $option = $field_name_metaflac_option{$_} ;
		 my @tags = get_tag_value_array $values, $_ ;
		 map { ( "--set-tag", $option."=".$_ ) } @tags
		 } @field_names
	       ),
	     # TODO: handle other fields
	     ) ;
}

sub tag_with_fields {
    my $file = shift ;
    my $file_type = shift ;
    my $values = shift ;

    # is there actually something to do ?
    if ( !(keys %{$values}) ) {
	print "    Nothing to do.\n" ;
	return ;
    }

    # tagging command line
    my @system_args ;
    if ($file_type eq $mp3_type) {
	@system_args = ( (mp3_tagging_system_args $values), $file) ;
    } elsif ($file_type eq $ogg_type) {
	@system_args = ( (ogg_tagging_system_args $values), $file) ;
    } elsif ($file_type eq $flac_type) {
	@system_args = ( (flac_tagging_system_args $values), $file) ;
    }

    # show command line and really tag if asked
    if ($dry_run_opt or $verbose_opt) {
	print "      '". +(join "' '", @system_args) ."'\n" ;
    }
    if (!$dry_run_opt) {
	print "    Tagging.\n" ;
	my ($status, @output) = system_with_output @system_args ;
	if ($status) {
	    print "      Tagging failed, command line was: ". join (" ", @system_args) ."\n" ;
	    while (my $line = shift @output) {
		print "# $line" ;
	    }
	}
    }
}

#############################################
# renaming

sub rename_confirm_usage {
    my $behaviors = shift ;
    print "      y => Yes, rename this file (default)\n" ;
    print "      a => Always rename without asking\n" ;
    print "      e => Edit the filename before tagging\n" ;
    print "      n => No, don't rename this file\n" ;
    print "      h => Show this help\n" ;
}

sub rename_with_tags {
    my $file = shift ;
    my $file_type = shift ;
    my $values = shift ;

    my $rename_values = {} ;
    my $undefined = 0 ;

    print "  Renaming with format '$rename_opt'...\n" ;

    foreach my $field (keys %{$values}) {
	# use the first tag for renaming
	my $val = get_tag_unique_value $values, $field ;
	$val = lc ($val)
	    if $rename_min_opt ;
	$val =~ s/ /$rename_sep_opt/g
	    if $rename_sep_opt ;
	map { $val = apply_regexp_to_tag ($val, $_, $field) } @rename_regexp_opts ;
	$rename_values->{$field} = $val ;
    }

    my $format_string = $rename_opt ;
    my @array = split(//, $format_string) ;
    for(my $i = 0; $i < @array - 1; $i++) {

	# normal characters
	next if $array[$i] ne "%" ;

	# remove % and check next char
	splice (@array, $i, 1) ;
	# replace the char with the matching
	my $char = $array[$i] ;
	next if $char eq "%" ;
	if ($char =~ /$field_letters_union/) {
	    my $field = $field_letter_name{$char} ;
	    my $val = $rename_values->{$field} ;
	    # rename does not contain an array anymore
	    if (not defined $val) {
		$undefined++ ;
		print "    WARNING: Undefined field '".$field."'.\n" ;
		$val = "" ;
	    }
	    if ($char eq 'n') {
		# initialize track number to 0 if empty
		$val = "0" if !$val ;
		# make it at least 2 digits
		$val = '0'.$val if $val < 10 and length $val < 2 ;
	    }
	    $array[$i] = $val ;
	} else {
	    $array[$i] = "%".$char ;
	}
    }

    my $new_name = join ("", @array) ;
    if (!$rename_ext_opt) {
	if ($file_type eq $mp3_type) {
	    $new_name .= ".". $mp3_ext ;
	} elsif ($file_type eq $ogg_type) {
	    $new_name .= ".". $ogg_ext ;
	} elsif ($file_type eq $flac_type) {
	    $new_name .= ".". $flac_ext ;
	}
    }

    print "    New filename is '$new_name'\n" ;

    # confirm if required or if any field undefined
    if ($undefined or !$current_rename_yes_opt) {
      ASK_CONFIRM:
	print "    Really rename the file [<y>aen,(h)elp] ? " ;
	my $reply = <> ;
	chomp $reply ;
        if ($reply eq "" or $reply =~ /^y/i) {
            goto RENAME_IT ;
	} elsif ($reply =~ /^a/i) {
	    $current_rename_yes_opt = 1 ;
            goto RENAME_IT ;
	} elsif ($reply =~ /^n/i) {
	    return ;
	} elsif ($reply =~ /^e/i) {
	    $new_name = &$myreadline ("      ", "New filename", $new_name, 0) ;
	    goto ASK_CONFIRM ;
	} else {
	    rename_confirm_usage ;
	    goto ASK_CONFIRM ;
	}
    }

  RENAME_IT:
    if ($new_name eq $file) {
	print "    Filename would not change, not renaming\n" ;
	return ;
    }

    if (-e $new_name) {
	print "    File $new_name already exists, not renaming\n" ;
	return ;
    }

    return
	if $dry_run_opt ;

    my $remain = $new_name ;
    my $path = '' ;
    while ($remain =~ /^([^\/]*\/+)(.*)$/) {
        $path .= $1 ;
	$remain = $2 ;
	if (!-d $path) {
	    print "      Creating directory '$path'\n" ;
	    if (!mkdir $path) {
		print "      ERROR: Failed to create directory ($!)\n" ;
		return ;
	    }
	}
    }

    print "    Renaming.\n" ;
    rename $file, $new_name
	or print "    ERROR: Failed to rename ($!)\n" ;
}

#######################################################
# main process

# read internal parsers
read_internal_parsers
    if $guess_opt or $list_formats_opt ;

# if -L was passed, show formats and exit
if ($list_formats_opt) {
    print "Listing internal parsers:\n" ;
    foreach my $path_parser (@internal_path_parsers) {
	foreach my $basename_parser (@internal_basename_parsers) {
	    print "  $path_parser->{title}/$basename_parser->{title}\n" ;
	}
    }
    exit 0 ;
}

# process remaining command-line arguments as files
my @files = () ;
while ( @ARGV ) {
    if ($recursive_opt) {
	my $dir = shift @ARGV ;
	open FIND, "find \"$dir\" |" ;
	my @dirfiles = <FIND> ;
	close FIND ;
	foreach my $file (@dirfiles) {
	    chomp $file ;
	    if (-f $file) {
		push (@files, $file) ;
	    }
	}
    } else {
	my $file = shift @ARGV ;
	if (-f $file) {
	    push (@files, $file) ;
	} else {
	    print "Skipping the non-file '$file'\n" ;
	}
    }
}

if ($show_tags_opt) {
    my @fields_to_show = split (/,/, $show_tags_opt) ;
    foreach my $file (@files) {
	print "$file:\n"
	    if @files ;

	my ($parsename, $file_type) = extract_parsename_and_type $file ;
	if (not defined $file_type) {
	    print "  Skipping this unknown-type file.\n" ;
	    next ;
	}

	my $values = read_tags $file, $file_type ;

	foreach my $field (@field_names) {
	    next if not defined $values->{$field} ;
	    my ($first, $remaining) = ($field =~ /^(.)(.*)$/) ;
	    $first = uc($first) ;
	    next unless grep { /^all$/ } @fields_to_show
		or grep { /^$first$remaining$/i } @fields_to_show ;
	    map { print "  $first$remaining=$_\n" } (get_tag_value_array $values, $field) ;
	}

	foreach my $field (get_values_non_regular_keys $values) {
	    map { print "  $field=$_\n" } (get_tag_value_array $values, $field) ;
	}
    }

    exit 0 ;
}

# generate user parsers
generate_user_parsers ;

# main loop
while ( @files ) {
    my $file = shift @files ;

    print "Processing file \"".$file."\"...\n" ;

    my ($parsename, $file_type) = extract_parsename_and_type $file ;
    if (not defined $file_type) {
	print "  Skipping this unknown-type file '$file'\n" ;
	goto NEXT_FILE ;
    }

    # read old tags
    my $old_values = read_tags $file, $file_type ;

    # try to parse this file
    my ($res, $values) = try_to_parse $file, $parsename, $file_type ;
    goto NEXT_FILE
	if $res == $TAG_SKIP_FILE ;
    die "Unknown tag return value: $res.\n"
	if $res != $TAG_SUCCESS and $res != $TAG_SUCCESS_PREFERRED ;

    # add new values to the old ones, depending on clear/append options
    my $new_values = append_tag_values $old_values, $values ;

    # actually tagging
    tag_with_fields $file, $file_type, $new_values
	unless $no_tagging_opt ;

    # renaming
    rename_with_tags $file, $file_type, $new_values
	if defined $rename_opt ;

    # next file
  NEXT_FILE:
    shift ;
}

#############################################
# generate configuration file

sub generate_config {
    my $file = shift ;
    die "Cannot generate $file which already exists."
        if -e "$file" ;
    open NEWCFG, ">$file"
        or die "Cannot open $file ($!).\n" ;

    print NEWCFG "# This is a lltag configuration file.\n" ;
    print NEWCFG "# It was automatically generated.\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;

    map { print NEWCFG "format = \"$_\"\n" ; } @user_format_strings ;

    print NEWCFG "guess = $guess_opt\n" ;
    print NEWCFG "nopath = $nopath_opt\n" ;

    map { print NEWCFG "default_$_ = \"$field_default{$_}\"\n" ; } (keys %field_default) ;

    print NEWCFG "spaces = $spaces_opt\n" ;
    print NEWCFG "maj = $maj_opt\n" ;
    print NEWCFG "sep = \"$sep_opt\"\n"
	if defined $sep_opt ;
    map { print NEWCFG "regexp = \"$_\"\n" ; } @regexp_opts ;
    print NEWCFG "type = ". (defined $type_opt?$type_opt:"none") ."\n" ;
    print NEWCFG "clear_tags = $clear_opt\n" ;
    print NEWCFG "append_tags = $append_opt\n" ;
    print NEWCFG "no_tagging = $no_tagging_opt\n" ;

    print NEWCFG "rename_format = \"" .($rename_opt?$rename_opt:""). "\"\n" ;
    print NEWCFG "rename_min = $rename_min_opt\n" ;
    print NEWCFG "rename_sep = \"$rename_sep_opt\"\n" ;
    map { print NEWCFG "rename_regexp = \"$_\"\n" ; } @rename_regexp_opts ;
    print NEWCFG "rename_ext = $rename_ext_opt\n" ;

    print NEWCFG "dry_run = $dry_run_opt\n" ;
    print NEWCFG "yes = $yes_opt\n" ;
    print NEWCFG "ask = $ask_opt\n" ;
    print NEWCFG "recursive = $recursive_opt\n" ;
    print NEWCFG "verbose = $verbose_opt\n" ;

    close NEWCFG ;
}

generate_config $gencfg_file
    if defined $gencfg_file ;

#######################################################
# save readline history if supported by the installation

# only keep the last 100 entries
eval {
  $term->StifleHistory (100);
} unless $term->Features->{StifleHistory} ;

# save the history file
eval {
    if (!-d $user_lltag_dir."/") {
	mkdir $user_lltag_dir
	    or warn "Failed to create $user_lltag_dir directory to store the history file: $!.\n" ;
    }
    $term->WriteHistory ($user_lltag_dir."/".$lltag_edit_history_filename)
	or warn "Failed to write history file $user_lltag_dir/$lltag_edit_history_filename: $!.\n" ;
} unless $term->Features->{WriteHistory} ;

