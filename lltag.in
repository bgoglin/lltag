#!/usr/bin/perl -w

use strict ;
no strict "refs" ; # for $backend{$file_type}

require Lltag::Tags ;
require Lltag::Misc ;
require Lltag::MP3 ;
require Lltag::OGG ;
require Lltag::FLAC ;
require Lltag::CDDB ;
require Lltag::Parse ;
require Lltag::Rename ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

#######################################################
# main hash for globals and config
my $self = {} ;

#######################################################
# configuration file location
$self->{common_lltag_dir} = "@SYSCONFDIR@/lltag" ;
$self->{user_lltag_dir} = "$ENV{HOME}/.lltag" ;
$self->{lltag_format_filename} = "formats" ;
$self->{lltag_config_filename} = "config" ;
$self->{lltag_edit_history_filename} = "edit_history" ;

#######################################################
Lltag::Misc::init_readline ($self) ;

#######################################################
# format parameters

@{$self->{field_names}} = ('ARTIST', 'TITLE', 'ALBUM', 'NUMBER', 'GENRE', 'DATE', 'COMMENT') ;
@{$self->{field_letters}} = ('a', 't', 'A', 'n', 'g', 'd', 'c') ;

%{$self->{field_name_letter}} =
    (
     'ARTIST'  => 'a',
     'TITLE'   => 't',
     'ALBUM'   => 'A',
     'NUMBER'  => 'n',
     'GENRE'   => 'g',
     'DATE'    => 'd',
     'COMMENT' => 'c',
     ) ;

%{$self->{field_name_trailing_spaces}} =
    (
     'ARTIST' => '  ',
     'TITLE' => '   ',
     'ALBUM' => '   ',
     'NUMBER' => '  ',
     'GENRE' => '   ',
     'DATE' => '    ',
     'COMMENT' => ' ',
     ) ;

%{$self->{field_default}} = () ;

%{$self->{additional_values}} = () ;

%{$self->{field_letter_name}} =
    (
     'a' => 'ARTIST',
     't' => 'TITLE',
     'A' => 'ALBUM',
     'n' => 'NUMBER',
     'g' => 'GENRE',
     'd' => 'DATE',
     'c' => 'COMMENT',
     ) ;

# change format names into a parsing string
$self->{field_letters_union} = (join '|', @{$self->{field_letters}}) ;

#######################################################
# version
my $version = "@VERSION@" ;

sub version {
    print "This is lltag version $version.\n" ;
    exit 0 ;
}

#######################################################
# usage
sub usage {
    print $0." $version is a frontend to tag MP3/OGG/FLAC files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print " Tagging options:\n" ;
    print "  -F, --format <format>  Try format (multiple instances allowed)\n" ;
    print "  -G, --guess            Guess format (default)\n" ;
    print "  -C, --cddb             Query tags in CDDB\n" ;
    print "  -p, --nopath           Remove the path from filenames when matching\n" ;
    print map { "  -". $self->{field_name_letter}{$_} .", --". $_.$self->{field_name_trailing_spaces}{$_}
		    ."<val>    Set the default value for ". ucfirst($_) ."\n" } @{$self->{field_names}} ;
    print "  --tag <TAG=value>      Add <value> to tag <TAG>\n" ;
    print "  --spaces               Allow no or multiple spaces\n" ;
    print "  --maj                  Upcase first letters of words in tags\n" ;
    print "  --sep <s1|s2|...>      Replace |-separated strings with space in tags\n" ;
    print "  --regexp <regexp>      Apply a replace regexp to tags before tagging\n" ;
    print "  --mp3/--ogg/--flac     Force mp3, ogg or flac instead of by-extension detection\n" ;
    print "  --type <type>          Force <tyle> instead of by-extension detection\n" ;
    print "  --clear                Clear all tags of audio files when possible\n" ;
    print "  --append               Append tags only instead of replacing old ones when possible\n" ;
    print "  --no-tagging           Do not actually tag files\n" ;
    Lltag::Rename::rename_usage ($self) ;
    print " General options:\n" ;
    print "  --dry-run              Do nothing but show what would have been done\n" ;
    print "  --yes                  Tag without asking for confirmation when guessing\n" ;
    print "                         Rename without asking for confirmation\n" ;
    print "  --ask                  Always ask for confirmation before tagging\n" ;
    print "  -R, --recursive        Recursively search all files in subdirectories\n" ;
    print "  -v, --verbose          Verbose messages\n" ;
    print "  --config <file>        Read additional configuration file\n" ;
    print "  --gencfg <file>        Generate additional configuration file\n" ;
    print " CDDB options:\n" ;
    print "  --cddb-server <server> Change the CDDB server and port\n" ;
    print "  --cddb-proxy <server>  Use a HTTP proxy to access the CDDB server\n" ;
    print " Behavior options:\n" ;
    print "  -S                     Show all tags from files\n" ;
    print "  --show-tags <tag,..>   Show several tags from files\n" ;
    print "  -L, --list             List internal formats\n" ;
    print "  -V, --version          Show lltag version\n" ;
    print "  -h, --help             Show this help\n" ;
    print " Format is composed of anything you want with special fields:\n" ;
    print map { "  %". $self->{field_name_letter}{$_} ." means ". ucfirst($_) ."\n" } @{$self->{field_names}} ;
    Lltag::Parse::parsing_format_usage ($self) ;
    Lltag::Rename::rename_format_usage ($self) ;
    print "\n" ;
    print "Author:    Brice Goglin\n" ;
    print "Homepage:  http://home.gna.org/lltag\n" ;
    print "Report bugs to:  <lltag-users AT gna.org>\n" ;
    exit 1;
}

#######################################################
# options

$self->{dry_run_opt} = 0 ;
$self->{verbose_opt} = 0 ;
$self->{recursive_opt} = 0 ;
$self->{list_formats_opt} = 0 ;
$self->{show_tags_opt} = "" ;
$self->{no_tagging_opt} = 0 ;

%{$self->{additional_values}} = () ;
@{$self->{additional_tags}} = () ;

$self->{ask_opt} = 0 ;
$self->{guess_opt} = 0 ;
$self->{cddb_opt} = 0 ;
$self->{nopath_opt} = 0 ;
$self->{maj_opt} = 0 ;
$self->{sep_opt} = undef ;
$self->{spaces_opt} = 0 ;
$self->{type_opt} = undef ;
$self->{yes_opt} = 0 ;
$self->{clear_opt} = 0 ;
$self->{append_opt} = 0 ;
@{$self->{regexp_opts}} = () ;

$self->{rename_opt} = undef ;
$self->{rename_min_opt} = 0 ;
$self->{rename_sep_opt} = " " ;
$self->{rename_ext_opt} = 0 ;
@{$self->{rename_regexp_opts}} = () ;

$self->{gencfg_file} = undef ;

@{$self->{user_format_strings}} = () ;

$self->{cddb_server_name} = "www.freedb.org" ;
$self->{cddb_server_port} = 80 ;
$self->{cddb_proxy_name} = undef ;
$self->{cddb_proxy_port} = undef ;

#######################################################
# parse config files first

my @additional_config_files = () ;

# process these options but kept other options in @ARGV for later
Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'config=s'     => \@additional_config_files,
        ) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

sub process_option {
    $_ = shift ;
    chomp $_ ;
    if (/^format\s*=\s*"(.+)"$/) {
	push (@{$self->{user_format_strings}}, $1) ;
    } elsif (/^guess\s*=\s*(.+)$/) {
	$self->{guess_opt} = $1 ;
    } elsif (/^nopath\s*=\s*(.+)$/) {
	$self->{nopath_opt} = $1 ;
    } elsif (/^default_([^ ]*)\s*=\s*"(.*)"$/) {
        die "Unrecognized option line #$.: \"$_\"\n"
	    # TODO: drop non-capitalized field name support on september 20 2006
	    unless defined $self->{field_name_letter}{uc ($1)} ;
	# TODO: drop filename support on september 20 2006
	$self->{field_default}{uc ($1)} = $2 ;
    } elsif (/^tag\s*=\s*"(.+)"$/) {
	push @{$self->{additional_tags}}, $1 ;
    } elsif (/^spaces\s*=\s*(.+)$/) {
	$self->{spaces_opt} = $1 ;
    } elsif (/^maj\s*=\s*(.+)$/) {
	$self->{maj_opt} = $1 ;
    } elsif (/^sep\s*=\s*"(.*)"$/) {
	$self->{sep_opt} = $1 ;
    } elsif (/^type\s*=\s*(.+)$/) {
	if ($1 eq "none") {
	    $self->{type_opt} = undef ;
	} else {
	    $self->{type_opt} = $1 ;
	}
    } elsif (/^regexp\s*=\s*"(.+)"$/) {
	push (@{$self->{regexp_opts}}, $1) ;
    } elsif (/^clear_tags\s*=\s*(.+)$/) {
	$self->{clear_opt} = $1 ;
    } elsif (/^append_tags\s*=\s*(.+)$/) {
	$self->{append_opt} = $1 ;
    } elsif (/^no_tagging\s*=\s*(.+)$/) {
	$self->{no_tagging_opt} = $1 ;
    } elsif (/^rename_format\s*=\s*"(.*)"$/) {
	if ($1 eq "") {
	    $self->{rename_opt} = undef ;
	} else {
	    $self->{rename_opt} = $1 ;
	}
    } elsif (/^rename_min\s*=\s*(.+)$/) {
	$self->{rename_min_opt} = $1 ;
    } elsif (/^rename_sep\s*=\s*"(.*)"$/) {
	$self->{rename_sep_opt} = $1 ;
    } elsif (/^rename_regexp\s*=\s*"(.+)"$/) {
	push (@{$self->{rename_regexp_opts}}, $1) ;
    } elsif (/^rename_ext\s*=\s*(.+)$/) {
	$self->{rename_ext_opt} = $1 ;
    } elsif (/^dry_run\s*=\s*(.+)$/) {
	$self->{dry_run_opt} = $1 ;
    } elsif (/^yes\s*=\s*(.+)$/) {
	$self->{yes_opt} = $1 ;
	$self->{ask_opt} = 0 if $1 ;
    } elsif (/^ask\s*=\s*(.+)$/) {
	$self->{ask_opt} = $1 ;
	$self->{yes_opt} = 0 if $1 ;
    } elsif (/^recursive\s*=\s*(.+)$/) {
	$self->{recursive_opt} = $1 ;
    } elsif (/^verbose\s*=\s*(.+)$/) {
	$self->{verbose_opt} = $1 ;
    } elsif (/^cddb\s*=\s*(.+)$/) {
	$self->{cddb_opt} = $1 ;
    } elsif (/^cddb_server_name\s*=\s*"(.+)"$/) {
	$self->{cddb_server_name} = $1 ;
    } elsif (/^cddb_server_port\s*=\s*(\d+)$/) {
	$self->{cddb_server_port} = $1 ;
    } elsif (/^cddb_proxy_name\s*=\s*"(.*)"$/) {
	$self->{cddb_proxy_name} = $1 ;
    } elsif (/^cddb_proxy_port\s*=\s*(\d*)$/) {
	$self->{cddb_proxy_port} = $1 ;
# Error
    } elsif (/^[^#]/ && !/^(\s*)$/) {
        die "Unrecognized option line #$.: \"$_\"\n" ;
    }
}

sub parse_generic_config_file {
    my $file = shift ;
    open CONF, $file
        or return ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

parse_generic_config_file "$self->{common_lltag_dir}/$self->{lltag_config_filename}" ;
parse_generic_config_file "$self->{user_lltag_dir}/$self->{lltag_config_filename}" ;

sub parse_additional_config_file {
    my $file = shift ;
    open CONF, $file
        or die "Failed to open additional configuration file '$file' ($!).\n" ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

foreach my $file (@additional_config_files) {
    parse_additional_config_file $file ;
}

#######################################################
# parse cmdline options

# parse options
GetOptions(
	   'F|format=s'   => \@{$self->{user_format_strings}},
	   'G|guess'      => \$self->{guess_opt},
	   'C|cddb'       => \$self->{cddb_opt},
	   'p|nopath'     => \$self->{nopath_opt},
	   'spaces'       => \$self->{spaces_opt},
	   'maj'          => \$self->{maj_opt},
	   'sep=s'        => \$self->{sep_opt},
	   'regexp=s'     => \@{$self->{regexp_opts}},
	   # we do not use backends here since it would require to load them
	   # before parsing the command-line, and is useless anyway
	   'mp3'          => sub { $self->{type_opt} = "mp3" ; },
	   'ogg'          => sub { $self->{type_opt} = "ogg" ; },
	   'flac'         => sub { $self->{type_opt} = "flac" ; },
	   'type=s'	  => sub { shift ; $self->{type_opt} = shift ; },
	   'clear'        => \$self->{clear_opt},
	   'append'       => \$self->{append_opt},
	   'no-tagging'   => \$self->{no_tagging_opt},
	   'rename=s'     => \$self->{rename_opt},
	   'rename-min'   => \$self->{rename_min_opt},
	   'rename-sep=s' => \$self->{rename_sep_opt},
	   'rename-regexp=s' => \@{$self->{rename_regexp_opts}},
	   'rename-ext'   => \$self->{rename_ext_opt},
	   'dry-run'      => \$self->{dry_run_opt},
	   'R|recursive'  => \$self->{recursive_opt},
	   'yes'          => sub { $self->{yes_opt} = 1 ; $self->{ask_opt} = 0 ; },
	   'ask'          => sub { $self->{ask_opt} = 1 ; $self->{yes_opt} = 0 ; },
	   'cddb-server=s'=> sub { shift ; my $name = shift ;
				   if ($name =~ /(.*):(.*)/) {
					$self->{cddb_server_name} = $1 ;
					$self->{cddb_server_port} = $2 ;
				   } else {
					$self->{cddb_server_name} = $name ;
					$self->{cddb_server_port} = 80 ;
				   }
			     },
	   'cddb-proxy=s' => sub { shift ; my $name = shift ;
				   if ($name =~ /(.*):(.*)/) {
					$self->{cddb_proxy_name} = $1 ;
					$self->{cddb_proxy_port} = $2 ;
				   } else {
					$self->{cddb_proxy_name} = $name ;
					$self->{cddb_proxy_port} = 80 ;
				   }
			     },
	   'v|verbose'    => \$self->{verbose_opt},
	   'gencfg=s'     => \$self->{gencfg_file},
	   'h|help'       => sub { usage () ; },
	   'V|version'    => sub { version () ; },
	   'L|list'       => \$self->{list_formats_opt},
	   'show-tags=s'  => \$self->{show_tags_opt},
	   'S'            => sub { $self->{show_tags_opt} = "all" ; },
	   'tag=s'        => \@{$self->{additional_tags}},
	   map { my $field = $_ ;
		 # use a sub because \$self->{field_default}{$field} always allocates it and assigns it to undef...
		 $self->{field_name_letter}{$field} .'|'. $field .'=s' => sub { shift ; $self->{field_default}{$field} = shift },
	       } @{$self->{field_names}} ,
	   ) or usage () ;

# if no user parsers, no defaults, no guess and no cddb, force guess
$self->{try_internals_opt} = 1
    if $self->{guess_opt} or ( !@{$self->{user_format_strings}}
			       and !(grep { defined $self->{field_default}{$_} } (keys %{$self->{field_default}}))
			       and !$self->{list_formats_opt} ) ;

# yes/ask option status may vary with user confirmation replies
my $current_main_yes_opt = $self->{yes_opt} ;
Lltag::CDDB::init_cddb ($self) ;
Lltag::Parse::init_parsing ($self) ;
Lltag::Rename::init_renaming ($self) ;

#######################################################
# backends

# hash backends by type
my %backends = () ;

# hash types by file extention
my %file_extension_to_backend_type = () ;

# return 0 on success, -1 on error, 1 on busy
sub register_backend {
    my $backend = shift ;
    return -1
	if not defined $backend ;

    my $backend_extension = $backend->{extension} ;
    my $backend_type = $backend->{type} ;
    my $backend_name = $backend->{name} ;

    if (defined $backends{$backend_type}) {
	print "Failed to register backend '$backend_name' since file type '$backend_type' already exists.\n"
	    if $self->{verbose_opt} ;
	return 1 ;
    }
    if (defined $file_extension_to_backend_type{$backend_extension}) {
	print "Failed to register backend '$backend_name' since file extenstion '$backend_extension' already exists.\n"
	    if $self->{verbose_opt} ;
	return 1 ;
    }

    $backends{$backend_type} = $backend ;
    $file_extension_to_backend_type{$backend_extension} = $backend_type ;

    print "Registered backend '$backend_name' for type '$backend_type' extension '$backend_extension'.\n"
	if $self->{verbose_opt} ;

    return 0 ;
}

# register MP3 backend
register_backend (Lltag::MP3->new ($self) ;

# register OGG backend
register_backend (Lltag::OGG->new ($self)) ;

# register FLAC backend
register_backend (Lltag::FLAC->new ($self)) ;

#######################################################
# check that the file type is correct

die "Unrecognized file type '$self->{type_opt}'.\n"
    if defined $self->{type_opt} and not defined $backends{$self->{type_opt}} ;

#######################################################
# extract backend and parsename

sub extract_parsename_and_backend {
    my $file = shift ;

    # split into parsename and extension, and remove the path if asked
    my @parts = split (/\./, $file) ;
    my $extension = pop @parts ;
    my $parsename = join (".", @parts) ;
    if ($self->{nopath_opt}) {
	my @parts = split (/\//, $parsename) ;
	$parsename = pop @parts ;
    }

    my $file_type ;
    if (defined $self->{type_opt}) {
	$file_type = $self->{type_opt} ;
    } else {
	# if not forced, get the type from the extension
	$file_type = $file_extension_to_backend_type{lc($extension)} ;
    }

    return ($parsename, undef)
	unless defined $file_type ;

    return ($parsename, $backends{$file_type}) ;
}

#######################################################
# show existing tags if --show-tags was passed

sub read_tags {
    my $file = shift ;
    my $backend = shift ;

    # extract tags as a stream
    my $read_tags_func = $backend->{read_tags} ;
    my ($status, @output) = &$read_tags_func ($self, $file) ;
    if ($status) {
	print "  Failed to get tags from file.\n" ;
	return undef ;
    }

    # extract tags from the stream
    my $values = {} ;
    while (my $line = shift @output) {
	chomp $line ;
	my ($field, $value) = ($line =~ /^(.*)=(.*)$/) ;
	next if !$value ;
	Lltag::Tags::append_tag_value ($self, $values, $field, $value) ;
    }

    return $values ;
}

#######################################################
# apply user-given regexp

sub apply_regexp_to_tag {
    my $val = shift ;
    my $regexp = shift ;
    my $tag = shift ;

    # parse the regexp
    if ($regexp =~ /(?:([^:]+):)?s\/([^\/]+)\/([^\/]*)\/$/) {
	my @tags = () ;
	@tags = split (/,/, $1) if $1;
	my $from = $2 ;
	my $to = $3 ;
	$val =~ s/$from/$to/g
	    if !@tags or grep { $tag eq $_ } @tags ;
    } else {
	die "Unrecognized user regexp '$regexp'.\n" ;
    }

    return $val ;
}

#######################################################
# real tagging

sub tag_with_values {
    my $file = shift ;
    my $backend = shift ;
    my $values = shift ;

    # is there actually something to do ?
    if ( !(keys %{$values}) ) {
	print "  Nothing to do.\n" ;
	return ;
    }

    # tagging command line
    my $tagging_system_args_func = $backend->{tagging_system_args} ;
    my @tagging_system_args = &{$tagging_system_args_func} ($self, $values) ;
    my @system_args = ( @tagging_system_args, $file) ;

    # show command line and really tag if asked
    if ($self->{dry_run_opt} or $self->{verbose_opt}) {
	print "  '". +(join "' '", @system_args) ."'\n" ;
    }
    if (!$self->{dry_run_opt}) {
	print "  Tagging.\n" ;
	my ($status, @output) = Lltag::Misc::system_with_output (@system_args) ;
	if ($status) {
	    print "    Tagging failed, command line was: ". join (" ", @system_args) ."\n" ;
	    while (my $line = shift @output) {
		print "# $line" ;
	    }
	}
    }
}

#######################################################
# main process

# read internal parsers
Lltag::Parse::read_internal_parsers ($self)
    if $self->{try_internals_opt} or $self->{list_formats_opt} ;

# if -L was passed, show formats and exit
if ($self->{list_formats_opt}) {
    print "Listing internal parsers:\n" ;
    Lltag::Parse::list_internal_parsers () ;
    exit 0 ;
}

# read additional tags
Lltag::Tags::get_additional_tag_values ($self) ;

# process remaining command-line arguments as files
my @files = () ;
while ( @ARGV ) {
    if ($self->{recursive_opt}) {
	my $dir = shift @ARGV ;
	open FIND, "find \"$dir\" |" ;
	my @dirfiles = <FIND> ;
	close FIND ;
	foreach my $file (@dirfiles) {
	    chomp $file ;
	    if (-f $file) {
		push (@files, $file) ;
	    }
	}
    } else {
	my $file = shift @ARGV ;
	if (-f $file) {
	    push (@files, $file) ;
	} else {
	    print "Skipping the non-file '$file'\n" ;
	}
    }
}

# display tags
if ($self->{show_tags_opt}) {
    my @fields_to_show = split (/,/, $self->{show_tags_opt}) ;
    foreach my $file (@files) {
	print "$file:\n"
	    if @files ;

	my ($parsename, $backend) = extract_parsename_and_backend $file ;
	if (not defined $backend) {
	    print "  Skipping this unknown-type file.\n" ;
	    next ;
	}

	my $values = read_tags $file, $backend ;

	foreach my $field (@{$self->{field_names}}, (Lltag::Tags::get_values_non_regular_keys ($self, $values))) {
	    next if not defined $values->{$field} ;
	    next unless grep { /^all$/ } @fields_to_show
		or grep { /^$field$/i } @fields_to_show ;
	    map { print "  $field=$_\n" } (Lltag::Tags::get_tag_value_array ($self, $values, $field)) ;
	}
    }

    exit 0 ;
}

# generate user parsers
Lltag::Parse::generate_user_parsers ($self) ;

# main reading/parsing/tagging/renaming loop
while ( @files ) {
    my $file = shift @files ;
    my $values = undef ;
    my $new_values = undef ;
    my $res ;

    print "\n" ;
    print "Processing file \"".$file."\"...\n" ;

    my ($parsename, $backend) = extract_parsename_and_backend $file ;
    if (not defined $backend) {
	print "  Skipping this file '$file' with unknown type.\n" ;
	goto NEXT_FILE ;
    }

    # read old tags
    my $old_values = read_tags $file, $backend ;

    # FIXME: parse first, to get the track number?

    my $first_round = 1 ;
    while (1) {

	# try preferred parser first
	($res, $values) = Lltag::Parse::try_to_parse_with_preferred ($self, $file, $parsename) ;
	goto ADD_DEFAULTS
	    if $res == Lltag::Parse->PARSE_SUCCESS ;
	die "Unknown tag return value: $res.\n"
	    unless $res == Lltag::Parse->PARSE_NO_MATCH ;

	# try CDDB, if enabled
	if ($self->{cddb_opt}) {
      TRY_CDDB:
	    ($res, $values) = Lltag::CDDB::get_cddb_tags ($self) ;
	    goto ADD_DEFAULTS
		if $res == Lltag::CDDB->CDDB_SUCCESS ;
	    die "Unknown CDDB return value: $res.\n"
		unless $res == Lltag::CDDB->CDDB_ABORT ;
	    # during first round, try parse before going to confirmation
	    # FIXME: option to disable parsing ?
	    goto ADD_DEFAULTS
		unless $first_round ;
	}

	# try to parse this file
      TRY_PARSE:
	($res, $values) = Lltag::Parse::try_to_parse ($self, $file, $parsename) ;
	goto ADD_DEFAULTS
	    if $res == Lltag::Parse->PARSE_SUCCESS or $res == Lltag::Parse->PARSE_SUCCESS_PREFERRED ;
	die "Unknown tag return value: $res.\n"
	    unless $res == Lltag::Parse->PARSE_NO_MATCH or $res == Lltag::Parse->PARSE_ABORT ;

      ADD_DEFAULTS:
	$first_round = 0;

	# add defaults
	foreach my $field (@{$self->{field_names}}) {
	    $values->{$field} = $self->{field_default}{$field} if not defined $values->{$field} and defined $self->{field_default}{$field} ;
	}

      CONFIRM:
	if (keys %{$values}) {
	    print "    Current tag values are:\n" ;
	    foreach my $field (@{$self->{field_names}}) {
		print "      ".ucfirst($field).$self->{field_name_trailing_spaces}{$field}.": ".$values->{$field}."\n"
		    if defined $values->{$field} ;
	    }
	} else {
	    print "    There are no current tag values.\n" ;
	}

	goto TAG
	    if $current_main_yes_opt ;

	while (1) {
	    Lltag::Misc::print_question ("  Use these tag values [yaPCEDqQ] (default is yes, h for help) ? ") ;
	    my $confirm_reply = <> ;
	    chomp $confirm_reply ;

	    # FIXME: option to display old values

	    # FIXME: option to display additonial values

	    goto TAG
		# FIXME: check confirm options and always, except if cddb
		if $confirm_reply =~ /^y/ or $confirm_reply eq "" ;
	    goto TRY_PARSE
		if $confirm_reply =~ /^P/ ;
	    goto TRY_CDDB
		if $confirm_reply =~ /^C/ ;
	    goto NEXT_FILE
		if $confirm_reply =~ /^s/ or $confirm_reply =~ /^q/ ;
	    goto EXIT
		if $confirm_reply =~ /^Q/ ;

	    if ($confirm_reply =~ /^a/) {
		$current_main_yes_opt = 1 ;
		goto TAG ;

	    } elsif ($confirm_reply =~ /^E/) {
		$values = Lltag::Tags::edit_values ($self, $values, $self->{field_names}) ;
		goto CONFIRM ;

	    } elsif ($confirm_reply =~ /^D/) {
		$values = undef ;
		goto ADD_DEFAULTS ;

	    } else {
		print "    y => Yes, use these tags (default)\n" ;
		print "    a => Always yes, stop asking for a confirmation\n" ;
		print "    P => Try to parse the file\n" ;
		print "    C => Query CDDB\n" ;
		print "    E => Edit values\n" ;
		print "    D => Only use default values\n" ;
		print "    s/q => Skip this file\n" ;
		print "    Q => Quit without tagging anything anymore\n" ;
		print "    h => Show this help\n" ;
	    }
	}

    }

  TAG:
    # FIXME: do that before confirmation

    # add new values to the old ones, depending on clear/append options
    $new_values = Lltag::Tags::append_tag_values ($self, $old_values, $values) ;

    # append additional tags too
    $new_values = Lltag::Tags::append_tag_values ($self, $new_values, $self->{additional_values}) ;

    # actually tagging
    tag_with_values $file, $backend, $new_values
	unless $self->{no_tagging_opt} ;

    # renaming
    if (defined $self->{rename_opt}) {
	my $extension = $backend->{extension} ;
	Lltag::Rename::rename_with_values ($self, $file, $extension, $new_values) ;
    }

    # next file
  NEXT_FILE:
    shift ;
    next ;

    # exit without tagging anything anymore
  EXIT:
    last ;
}

#############################################
# generate configuration file

sub generate_config {
    my $file = shift ;
    die "Cannot generate $file which already exists."
        if -e "$file" ;
    open NEWCFG, ">$file"
        or die "Cannot open $file ($!).\n" ;

    print NEWCFG "# This is a lltag configuration file.\n" ;
    print NEWCFG "# It was automatically generated.\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;

    map { print NEWCFG "format = \"$_\"\n" ; } @{$self->{user_format_strings}} ;

    print NEWCFG "guess = $self->{guess_opt}\n" ;
    print NEWCFG "nopath = $self->{nopath_opt}\n" ;

    map { print NEWCFG "default_$_ = \"$self->{field_default}{$_}\"\n" ; } (keys %{$self->{field_default}}) ;

    map { print NEWCFG "tag = \"$_\"\n" ; } @{$self->{additional_tags}} ;

    print NEWCFG "spaces = $self->{spaces_opt}\n" ;
    print NEWCFG "maj = $self->{maj_opt}\n" ;
    print NEWCFG "sep = \"$self->{sep_opt}\"\n"
	if defined $self->{sep_opt} ;
    map { print NEWCFG "regexp = \"$_\"\n" ; } @{$self->{regexp_opts}} ;
    print NEWCFG "type = ". (defined $self->{type_opt} ? $self->{type_opt} : "none") ."\n" ;
    print NEWCFG "clear_tags = $self->{clear_opt}\n" ;
    print NEWCFG "append_tags = $self->{append_opt}\n" ;
    print NEWCFG "no_tagging = $self->{no_tagging_opt}\n" ;

    print NEWCFG "rename_format = \"" .($self->{rename_opt} ? $self->{rename_opt} : ""). "\"\n" ;
    print NEWCFG "rename_min = $self->{rename_min_opt}\n" ;
    print NEWCFG "rename_sep = \"$self->{rename_sep_opt}\"\n" ;
    map { print NEWCFG "rename_regexp = \"$_\"\n" ; } @{$self->{rename_regexp_opts}} ;
    print NEWCFG "rename_ext = $self->{rename_ext_opt}\n" ;

    print NEWCFG "cddb = $self->{cddb_opt}\n" ;
    print NEWCFG "cddb_server_name = \"$self->{cddb_server_name}\"\n" ;
    print NEWCFG "cddb_server_port = $self->{cddb_server_port}\n" ;
    print NEWCFG "cddb_proxy_name = \"$self->{cddb_proxy_name}\"\n" if defined $self->{cddb_proxy_name} ;
    print NEWCFG "cddb_proxy_port = $self->{cddb_proxy_port}\n" if defined $self->{cddb_proxy_name} ;

    print NEWCFG "dry_run = $self->{dry_run_opt}\n" ;
    print NEWCFG "yes = $self->{yes_opt}\n" ;
    print NEWCFG "ask = $self->{ask_opt}\n" ;
    print NEWCFG "recursive = $self->{recursive_opt}\n" ;
    print NEWCFG "verbose = $self->{verbose_opt}\n" ;

    close NEWCFG ;
}

generate_config $self->{gencfg_file}
    if defined $self->{gencfg_file} ;

Lltag::Misc::exit_readline () ;
