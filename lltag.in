#!/usr/bin/perl -w

use strict ;
no strict "refs" ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

#######################################################
# configuration file location
my $common_lltag_dir = "@SYSCONFDIR@/lltag" ;
my $user_lltag_dir = "$ENV{HOME}/.lltag" ;
my $lltag_format_filename = "formats" ;
my $lltag_config_filename = "config" ;

#######################################################
# format parameters
# (%a = artist, %t = title, %A = album, %n = number, %g = genre, %y = year)
my @field_name = ('artist', 'title', 'album', 'number', 'genre', 'year', 'comment') ;
my @field_trailing_spaces = (' ', '  ', '  ', ' ', '  ', '   ', '') ;
my @field_letter = ('a', 't', 'A', 'n', 'g', 'y', 'c') ;
my @field_default = (undef, undef, undef, undef, undef, undef, undef) ;
my $fields = $#field_name + 1 ;

#######################################################
# version
my $version = "@VERSION@" ;

sub version {
    print "This is lltag version $version.\n" ;
    exit 0 ;
}

#######################################################
# usage
sub usage {
    print $0." $version is a frontend to tag MP3/OGG/FLAC files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print " Tagging options:\n" ;
    print "  -F, --format <format>  Try format (multiple instances allowed)\n" ;
    print "  -G, --guess            Guess format (default)\n" ;
    print "  -p, --nopath           Remove the path from filenames when matching\n" ;
    print map { "  -".$field_letter[$_].", --".$field_name[$_].$field_trailing_spaces[$_]
		    ." <val>    Set the default value for "
		    .ucfirst($field_name[$_])."\n" } ( 0 .. $fields-1 ) ;
    print "  --spaces               Allow no or multiple spaces\n" ;
    print "  --maj                  Upcase first letters of words in tags\n" ;
    print "  --sep <s1|s2|...>      Replace |-separated strings with space in tags\n" ;
    print "  --mp3/--ogg/--flac     Force mp3, ogg of flac instead of by-extension detection\n" ;
    print "  --clear                Clear all tags of audio files when possible\n" ;
    print "  --append               Append tags only instead of replacing old ones when possible\n" ;
    print "  --no-tagging           Do not actually tag files\n" ;
    print " Renaming options:\n" ;
    print "  --rename <format>      Rename file according to format\n" ;
    print "  --rename-min           Lowcase tags before renaming\n" ;
    print "  --rename-sep <s>       Replace space with s in tags before renaming\n" ;
    print "  --rename-ext           Assume the rename format provides an extension\n" ;
    print " General options:\n" ;
    print "  --dry-run              Do nothing but show what would have been done\n" ;
    print "  --yes                  Tag without asking for confirmation when guessing\n" ;
    print "                         Rename without asking for confirmation\n" ;
    print "  --ask                  Always ask for confirmation before tagging\n" ;
    print "  -R, --recursive        Recursively search all files in subdirectories\n" ;
    print "  -v, --verbose          Verbose messages\n" ;
    print "  --config <file>        Read additional configuration file\n" ;
    print "  --gencfg <file>        Generate additional configuration file\n" ;
    print " Behavior options:\n" ;
    print "  -S                     Show all tags from files\n" ;
    print "  --show-tags <tag,..>   Show several tags from files\n" ;
    print "  -L, --list             List internal formats\n" ;
    print "  -V, --version          Show lltag version\n" ;
    print "  -h, --help             Show this help\n" ;
    print " Format is composed of anything you want with special fields:\n" ;
    print map { "  %".$field_letter[$_]." means ".ucfirst($field_name[$_])."\n" } ( 0 .. $fields-1 ) ;
    print "  %d means Dummy text\n" ;
    print "  %% means %\n" ;
    print "\n" ;
    print "Author:    Brice Goglin\n" ;
    print "Homepage:  http://home.gna.org/lltag\n" ;
    print "Report bugs to:  <lltag-users AT gna.org>\n" ;
    exit 1;
}

#######################################################
# globals

my $mp3_type = "mp3" ;
my $ogg_type = "ogg" ;
my $flac_type = "flac" ;

# subregexp
my $match_path = '(?:[^/]*\/)*' ;
my $match_any = '((?:[^ /]+ +)*[^ /]+)' ;
my $match_num = '([0-9]+)' ;
my $match_space = ' ';
my $match_spaces = ' *' ;
my $match_limit = '' ;

# the parser that the user wants to always use
my $preferred_parser = undef ;

#######################################################
# options

my $dry_run_opt = 0 ;
my $verbose_opt = 0 ;
my $recursive_opt = 0 ;
my $list_formats_opt = 0 ;
my $show_tags_opt = "" ;
my $no_tagging_opt = 0 ;

my $ask_opt = 0 ;
my $guess_opt = 0 ;
my $nopath_opt = 0 ;
my $maj_opt = 0 ;
my $sep_opt = undef ;
my $spaces_opt = 0 ;
my $type_opt = undef ;
my $yes_opt = 0 ;
my $default_opt = 0 ;
my $clear_opt = 0 ;
my $append_opt = 0 ;

my $rename_opt = undef ;
my $rename_min_opt = 0 ;
my $rename_sep_opt = " " ;
my $rename_ext_opt = 0 ;

my $mp3_ext = "mp3" ;
my $ogg_ext = "ogg" ;
my $flac_ext = "flac" ;

my $gencfg_file = undef ;

# parsers
my @format_strings = () ;

#######################################################
# parse config files first

my @additional_config_files = () ;

# process these options but kept other options in @ARGV for later
Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'config=s'     => \@additional_config_files,
        ) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

sub process_option {
    $_ = shift ;
    chomp $_ ;
    if (/^format\s*=\s*"(.+)"$/) {
	push (@format_strings, $1) ;
    } elsif (/^guess\s*=\s*(.+)$/) {
	$guess_opt = $1 ;
    } elsif (/^nopath\s*=\s*(.+)$/) {
	$nopath_opt = $1 ;
    } elsif (/^default_([^ ]*)\s*=\s*"(.*)"$/) {
	my @indices = grep { $field_name[$_] eq $1 } ( 0 .. $fields-1 ) ;
        die "Unrecognized option line #$.: \"$_\"\n"
	    if ! @indices ;
	my $indice = $indices[0] ;
	$field_default[$indice]	= $2 ;
    } elsif (/^spaces\s*=\s*(.+)$/) {
	$spaces_opt = $1 ;
    } elsif (/^maj\s*=\s*(.+)$/) {
	$maj_opt = $1 ;
    } elsif (/^sep\s*=\s*"(.*)"$/) {
	$sep_opt = $1 ;
    } elsif (/^type\s*=\s*(.+)$/) {
	if ($1 eq "none") {
	    $type_opt = undef ;
	} elsif ($1 ne $mp3_type and $1 ne $ogg_type and $1 ne $flac_type) {
	    die "Unrecognized type '$1' line #$\n" ;
	} else {
	    $type_opt = $1 ;
	}
    } elsif (/^clear_tags\s*=\s*(.+)$/) {
	$clear_opt = $1 ;
    } elsif (/^append_tags\s*=\s*(.+)$/) {
	$append_opt = $1 ;
    } elsif (/^no_tagging\s*=\s*(.+)$/) {
	$no_tagging_opt = $1 ;
    } elsif (/^rename_format\s*=\s*"(.*)"$/) {
	if ($1 eq "") {
	    $rename_opt = undef ;
	} else {
	    $rename_opt = $1 ;
	}
    } elsif (/^rename_min\s*=\s*(.+)$/) {
	$rename_min_opt = $1 ;
    } elsif (/^rename_sep\s*=\s*"(.*)"$/) {
	$rename_sep_opt = $1 ;
    } elsif (/^rename_ext\s*=\s*(.+)$/) {
	$rename_ext_opt = $1 ;
    } elsif (/^dry_run\s*=\s*(.+)$/) {
	$dry_run_opt = $1 ;
    } elsif (/^yes\s*=\s*(.+)$/) {
	$yes_opt = $1 ;
	$ask_opt = 0 if $1 ;
    } elsif (/^ask\s*=\s*(.+)$/) {
	$ask_opt = $1 ;
	$yes_opt = 0 if $1 ;
    } elsif (/^recursive\s*=\s*(.+)$/) {
	$recursive_opt = $1 ;
    } elsif (/^verbose\s*=\s*(.+)$/) {
	$verbose_opt = $1 ;
# Error
    } elsif (/^[^#]/ && !/^(\s*)$/) {
        die "Unrecognized option line #$.: \"$_\"\n" ;
    }
}

sub parse_generic_config_file {
    my $file = shift ;
    open CONF, $file
        or return ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

parse_generic_config_file "$common_lltag_dir/$lltag_config_filename" ;
parse_generic_config_file "$user_lltag_dir/$lltag_config_filename" ;

sub parse_additional_config_file {
    my $file = shift ;
    open CONF, $file
        or die "Failed to open additional configuration file '$file' ($!).\n" ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

foreach my $file (@additional_config_files) {
    parse_additional_config_file $file ;
}

#######################################################
# parse cmdline options

# parse options
GetOptions(
	   'F|format=s'   => \@format_strings,
	   'G|guess'      => \$guess_opt,
	   'p|nopath'     => \$nopath_opt,
	   'spaces'       => \$spaces_opt,
	   'maj'          => \$maj_opt,
	   'sep=s'        => \$sep_opt,
	   'mp3'          => sub { $type_opt = $mp3_type ; },
	   'ogg'          => sub { $type_opt = $ogg_type ; },
	   'flac'         => sub { $type_opt = $flac_type ; },
	   'clear'        => \$clear_opt,
	   'append'       => \$append_opt,
	   'no-tagging'   => \$no_tagging_opt,
	   'rename=s'     => \$rename_opt,
	   'rename-min'   => \$rename_min_opt,
	   'rename-sep=s' => \$rename_sep_opt,
	   'rename-ext'   => \$rename_ext_opt,
	   'dry-run'      => \$dry_run_opt,
	   'R|recursive'  => \$recursive_opt,
	   'yes'          => sub { $yes_opt = 1 ; $ask_opt = 0 ; },
	   'ask'          => sub { $ask_opt = 1 ; $yes_opt = 0 ; },
	   'v|verbose'    => \$verbose_opt,
	   'gencfg=s'     => \$gencfg_file,
	   'h|help'       => sub { usage () ; },
	   'V|version'    => sub { version () ; },
	   'L|list'       => \$list_formats_opt,
	   'show-tags=s'  => \$show_tags_opt,
	   'S'            => sub { $show_tags_opt = "all" ; },
	   map { my $i = $_; $field_letter[$i].'|'.$field_name[$i].'=s'
		=> sub { shift ; $field_default[$i] = shift ; $default_opt = 1 ; },
	  	} ( 0 .. $fields-1 )
	   ) or usage () ;

# yes/ask option status may vary with user confirmation replies
my $current_yes_opt = $yes_opt ;
my $current_ask_opt = $ask_opt ;

# confirmation when renaming
my $current_rename_yes_opt = $yes_opt ;

# spaces_opt changes matching regexps
$match_limit = $match_space = $match_spaces if $spaces_opt ;

# if no parsers and no guess, force guess
$guess_opt = 1 unless @format_strings or $default_opt or $list_formats_opt ;

#######################################################
# Tagging return values
my $TAG_SUCCESS_PREFERRED = 1 ;
my $TAG_SUCCESS = 0 ;
my $TAG_SKIP_FILE = -1 ;
my $TAG_SKIP_PARSER = -2 ;
my $TAG_SKIP_PATH_PARSER = -3 ;
my $TAG_NO_MATCH = -4 ;

#######################################################
# Tagging acceptable behavior
my $TAG_MAY_SKIP_PARSER = 1 ;
my $TAG_MAY_SKIP_PATH_PARSER = 2 ;
my $TAG_MAY_PREFER = 4 ;

#######################################################
# rewrite of system which returns a descriptor of a stream
# containing both stdout and stderr
sub system_with_output {
    pipe (my $pipe_out, my $pipe_in) ;
    my $pid = fork() ;
    if ($pid < 0) {
	# in the father, when fork failed
	close $pipe_in ;
	close $pipe_out ;
	return (-1, "Failed to fork to execute command line: ". join (" ", @_) ."\n") ;
    } elsif ($pid > 0) {
	# in the father, when fork done
	close $pipe_in ;
	waitpid($pid, 0);
	my $status = $? >> 8 ;
	$status = -1
	    if $status == 255 ;
	my @lines = <$pipe_out> ;
	close $pipe_out ;
	return ( $status , @lines ) ;
    } else {
	# in the child
	close $pipe_out ;
	open STDERR, ">&", $pipe_in ;
	open STDOUT, ">&", $pipe_in ;
	{ exec @_ } ;
	print $pipe_in "Failed to execute command line: ". join (" ", @_) ."\n" ;
	print $pipe_in "Please install $_[0] properly (see README).\n"
	    if $!{ENOENT} or $!{EPERM} ;
	close $pipe_in ;
	exit -1 ;
    }
}

#######################################################
# files to process

# process remaining command-line arguments as files

my @files = () ;
while ( @ARGV ) {
    if ($recursive_opt) {
	my $dir = shift @ARGV ;
	open FIND, "find \"$dir\" |" ;
	my @dirfiles = <FIND> ;
	close FIND ;
	foreach my $file (@dirfiles) {
	    chomp $file ;
	    if (-f $file) {
		push (@files, $file) ;
	    }
	}
    } else {
	my $file = shift @ARGV ;
	if (-f $file) {
	    push (@files, $file) ;
	} else {
	    print "Skipping the non-file '$file'\n" ;
	}
    }
}

#######################################################
# show existing tags if --show-tags was passed

sub mp3_show_tags {
    my $filename = shift ;
    my ($status, @output) = system_with_output
	("mp3info", "-p", "Artist=%a\nAlbum=%l\nTitle=%t\nNumber=%n\nGenre=%g\nYear=%y\nComment=%c\n", $filename) ;
    return ($status)
	if $status ;
    return ($status, @output) ;
}

sub ogg_show_tags {
    my $filename = shift ;
    my ($status, @output) = system_with_output
	("vorbiscomment", "-l", $filename) ;
    return ($status)
	if $status ;
    return ($status, @output) ;
}

sub flac_show_tags {
    my $filename = shift ;
    my ($status, @output) = system_with_output
	("metaflac", "--list", "--block-type=VORBIS_COMMENT", $filename) ;
    return ($status)
	if $status ;
    @output = map { my $line =$_ ; $line =~ s/^\s*comment\[\d+\]\s*:\s*(.*)/$1/ ; $line } ( grep { /comment\[\d+\]/ } @output ) ;
    return ($status, @output) ;
}

if ($show_tags_opt) {
    my @fields_to_show = split (/,/, $show_tags_opt) ;
    foreach my $filename (@files) {
	# split into filename and extension
	my @parts = split (/\./, $filename) ;
	my $extension = pop @parts ;

	print "$filename:\n"
	    if @files ;

	# find out file type
	my $tag_type = $type_opt ;
	if (not defined $tag_type) {
	    # use the extension to find the type
	    if ($extension =~ /$mp3_ext/i) {
		$tag_type = $mp3_type ;
	    } elsif ($extension =~ /$ogg_ext/i) {
		$tag_type = $ogg_type ;
	    } elsif ($extension =~ /$flac_ext/i) {
		$tag_type = $flac_type ;
	    } else {
		print "  Skipping this unknown-type file.\n" ;
		next ;
	    }
	}

	# get the tags
	my $status ;
	my @output ;
	if ($tag_type eq $mp3_type) {
	    ($status, @output) = mp3_show_tags $filename ;
	} elsif ($tag_type eq $ogg_type) {
	    ($status, @output) = ogg_show_tags $filename ;
	} elsif ($tag_type eq $flac_type) {
	    ($status, @output) = flac_show_tags $filename ;
	}
	if ($status) {
	    print "  Failed to get tags from file.\n" ;
	    next ;
	}

	my @lines = () ;
	while (my $line = shift @output) {
	    chomp $line ;
	    $line =~ s/^tracknumber=/number=/i ;
	    my ($first, $remaining, $value) = ($line =~ /(.)(.*)=(.*)/) ;
	    next if !$value ;
	    $first = uc($first) ;
	    $remaining = lc($remaining) ;
	    next unless grep { /^all$/ } @fields_to_show
		or grep { /^$first$remaining$/i } @fields_to_show ;
	    push (@lines, "$first$remaining=$value") ;
	}

	map { print "  $_\n" } @lines ;
    }
    exit 0 ;
}

#######################################################
# internal parsers

my @internal_filename_parsers = () ;
my @internal_path_parsers = () ;

if ($guess_opt or $list_formats_opt) {
    # get parsers from configuration files
    my $file ;
    if (open FORMAT, "$user_lltag_dir/$lltag_format_filename") {
	$file = "$user_lltag_dir/$lltag_format_filename" ;
    } elsif (open FORMAT, "$common_lltag_dir/$lltag_format_filename") {
	$file = "$common_lltag_dir/$lltag_format_filename" ;
    } else {
	print "Did not find any format file.\n" ;
	goto NO_FORMATS_FILE_FOUND;
    }
    print "Reading format file '$file'...\n" if $verbose_opt ;

    my $type = undef ;
    my $title = undef ;
    my $regexp = undef ;
    my @indice_table = () ;

    while (<FORMAT>) {
	chomp $_ ;
	next if /^#/ ;
	next if /^$/ ;
	if (/^\[(.*)\]$/) {
	    if ($type and $title and $regexp and @indice_table) {
		my $parser ;
		$parser->{title} = $title ;
		$parser->{regexp} = $regexp ;
		$parser->{indices} = @indice_table ;
		for(my $i = 0; $i < @indice_table; $i++) {
		    $parser->{$i} = $indice_table[$i] ;
		}
		if ($type eq "filename") {
		    print "  Got filename format '$title'\n" if $verbose_opt ;
		    push (@internal_filename_parsers, $parser) ;
		} elsif ($type eq "path") {
		    print "  Got path format '$title'\n" if $verbose_opt ;
		    push (@internal_path_parsers, $parser) ;
		}
	    } elsif ($type or $title or $regexp or @indice_table) {
		die "Incomplete format at line $. in file '$file'\n" ;
	    }
	    $type = undef ; $regexp = undef ; @indice_table = () ;
	    $title = $1 ;
	    # stocker la ligne ?
	} elsif (/^type = (.*)$/) {
	    die "Unsupported format type '$1' at line $. in file '$file'\n"
		if $1 ne "filename" and $1 ne "path" ;
	    $type = $1 ;
	} elsif (/^regexp = (.*)$/) {
	    $regexp = $1 ;
	    $regexp =~ s/\./\\./g ;
	    $regexp =~ s/\)/\\\)/g ;
	    $regexp =~ s@/@\\/@g ;
	    # do the replacement progressively so that %% and %x and not mixed
	    while ($regexp =~ m/(%(?:P|L|S|N|A|%))/) {
		if ($1 eq '%P') {
		    $regexp =~ s/%P/$match_path/ ;
		} elsif ($1 eq '%L') {
		    $regexp =~ s/%L/$match_limit/ ;
		} elsif ($1 eq '%S') {
		    $regexp =~ s/%S/$match_space/ ;
		} elsif ($1 eq '%N') {
		    $regexp =~ s/%N/$match_num/ ;
		} elsif ($1 eq '%A') {
		    $regexp =~ s/%A/$match_any/ ;
		} elsif ($1 eq '%%') {
		    $regexp =~ s/%%/%/ ;
		}
	    }
	} elsif (/^indices = (.*)$/) {
	    @indice_table = split (/,/, $1) ;
	    for(my $i = 0; $i < @indice_table; $i++) {
		my $indice = ( grep { $field_letter[$_] eq $indice_table[$i] } ( 0 .. $fields-1 ) ) [0] ;
		if (not defined $indice) {
		    die "Unrecognized field letter '$indice_table[$i]' on line $. in file '$file'\n"
			if $indice_table[$i] ne 'd' ;
		    $indice = -1 ;
		}
		$indice_table[$i] = $indice ;
	    }
	} else {
	    die "Unrecognized line $. in file '$file': '$_'\n" ;
	}
    }
    close FORMAT ;

    # save the last format
    if ($type and $title and $regexp and @indice_table) {
	my $parser ;
	$parser->{title} = $title ;
	$parser->{regexp} = $regexp ;
	$parser->{indices} = @indice_table ;
	for(my $i = 0; $i < @indice_table; $i++) {
	    $parser->{$i} = $indice_table[$i] ;
	}
	if ($type eq "filename") {
	    print "  Got filename format '$title'\n" if $verbose_opt ;
	    push (@internal_filename_parsers, $parser) ;
	} elsif ($type eq "path") {
	    print "  Got path format '$title'\n" if $verbose_opt ;
	    push (@internal_path_parsers, $parser) ;
	}
    } elsif ($type or $title or $regexp or @indice_table) {
	die "Incomplete format at line $. in file '$file'\n" ;
    }
  NO_FORMATS_FILE_FOUND:
}

# if -L was passed, show formats and exit
if ($list_formats_opt) {
    print "Listing internal parsers:\n" ;
    foreach my $path_parser (@internal_path_parsers) {
	foreach my $filename_parser (@internal_filename_parsers) {
	    print "  $path_parser->{title}/$filename_parser->{title}\n" ;
	}
    }
    exit 0 ;
}

#######################################################
# merge path and filename internal parsers
sub merge_internal_parsers
{
    my $path_parser = shift ;
    my $filename_parser = shift ;
    my $parser ;
    $parser->{title} = "$path_parser->{title}/$filename_parser->{title}" ;
    $parser->{regexp} = "$path_parser->{regexp}/$filename_parser->{regexp}" ;
    $parser->{indices} = $path_parser->{indices} + $filename_parser->{indices} ;
    for(my $i=0; $i < $path_parser->{indices}; $i++) {
	$parser->{$i} = $path_parser->{$i} ;
    }
    for(my $i=0; $i < $filename_parser->{indices}; $i++) {
	$parser->{$i+$path_parser->{indices}} = $filename_parser->{$i} ;
    }
    return $parser ;
}

# parse
sub parse_file_with_internal_parsers
{
    my $file = shift ;
    my $filename = shift ;
    my $tag_type = shift ;

    print "  with internal formats...\n" ;

    # split into path and parts if possible
    my @parts = split (/\//, $filename) ;
    $filename = pop @parts ;

    if (!$nopath_opt and @parts) {
	# try each path parser and each filename parser
	my $path = join ("/", @parts) ;
	foreach my $path_parser (@internal_path_parsers) {
	    if ($path =~ /^$path_parser->{regexp}$/) {
		foreach my $filename_parser (@internal_filename_parsers) {
		    # match the whole path+filename to get a clean @_ for tag_with_parser
		    if ("$path/$filename" =~ m/^$path_parser->{regexp}\/$filename_parser->{regexp}$/) {
			print "    '$path_parser->{title}/$filename_parser->{title}' matches this file\n" ;
			my $whole_parser = merge_internal_parsers ($path_parser, $filename_parser) ;
			# try to tag, with confirmation
			my $res = match_fields_with_parser ($file, $tag_type, $whole_parser,
							    1, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER|$TAG_MAY_SKIP_PATH_PARSER, @_) ;
			if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERRED || $res == $TAG_SKIP_FILE) {
			    if ($res == $TAG_SUCCESS_PREFERRED) {
				$preferred_parser = $whole_parser ;
			    }
			    return $res ;
			}
			# try next path parser if asked
			if ($res == $TAG_SKIP_PATH_PARSER) {
			    goto NEXT_PATH_PARSER;
			}
			# try next parser
			die "Unknown tag return value: $res\n" if $res != $TAG_SKIP_PARSER ;
		    }
		}
	    }
	  NEXT_PATH_PARSER:
	}
    } else {
	# no path, only try each filename parser
	foreach my $filename_parser (@internal_filename_parsers) {
	    if ($filename =~ /^$filename_parser->{regexp}$/) {
		print "    '$filename_parser->{title}' matches this file\n" ;
		# try to tag, with confirmation
		my $res = match_fields_with_parser ($file, $tag_type, $filename_parser,
						    1, $TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER, @_) ;
		if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERRED || $res == $TAG_SKIP_FILE) {
		    if ($res == $TAG_SUCCESS_PREFERRED) {
			$preferred_parser = $filename_parser ;
		    }
		    return $res ;
		}
		# try next parser
		die "Unknown tag return value: $res\n" if $res != $TAG_SKIP_PARSER ;
	    }
	}
    }
    # no parser was found or used
    return $TAG_NO_MATCH ;
}

#######################################################
# user parsers

# change format names into a parsing string
my $field_letters = (join '|', @field_letter) ;

# change a format strings into usable infos
sub generate_user_parser {
    my $format_string = shift ;

    print "Generating parser for format '". $format_string ."'...\n" ;

    my $parser ;
    $parser->{title} = $format_string ;

    # merge spaces if --spaces was passed
    if ($spaces_opt) {
	$format_string =~ s/ +/ /g ;
    }

    # create the regexp and store indice fields
    my @array = split(//, $format_string) ;
    my $j = 0 ;
    for(my $i = 0; $i < @array - 1; $i++) {

	my $char = $array[$i] ;
	# normal characters
	if ($char ne "%") {

	    if ($char eq " ") {
		# replace spaces with general space matching regexp
		$array[$i] = $match_space ;

	    } elsif ($char eq "/") {
		# replace / with space flexible matching regexp
		$array[$i] = $match_limit."/".$match_limit ;

	    } elsif (index ("()[]", $char) != -1) {
		# escape regexp control characters
		$array[$i] = "\\".$char ;

	    }
	    # keep this character
	    next ;
	}

	# remove % and check next char
	splice (@array, $i, 1) ;
	# replace the char with the matching
	$char = $array[$i] ;
	next if $char eq "%" ;
	if ($array[$i] eq "n") {
	    $array[$i] = $match_num ;
	} elsif ($array[$i] =~ /$field_letters|d/) {
	    $array[$i] = $match_any ;
	} else {
	    die "  ERROR: Format '". $format_string ."' contains unrecognized operator '%". $array[$i] ."'.\n" ;
	}
	# store the indice
	if ($char eq "d") {
	    $parser->{$j} = -1 ;
	} else {
	    my @indices = grep { $char eq $field_letter[$_] } ( 0 .. $fields-1 ) ;
	    $parser->{$j} = $indices[0] ;
	}
	$j++ ;
    }

    # done
    if ($spaces_opt) {
	$parser->{regexp} = $match_limit. join("", @array) .$match_limit ;
    } else {
	$parser->{regexp} = join("", @array) ;
    }
    $parser->{indices} = $j ;

    # check insolvable regexp
    for(my $i = 0; $i < @array - 1; $i++) {
	my $char = $array[$i] ;
	my $nextchar = $array[$i+1] ;
	if ( $char eq $match_any and
	     ( $nextchar eq $match_any or $nextchar eq $match_num ) ) {
	    print "  WARNING: Format '". $format_string
		."' leads to problematic subregexp '". $char.$nextchar
		."' that won't probably match as desired.\n" ;
	}
    }

    if ($verbose_opt) {
	print "  Format string will parse with: ". $parser->{regexp} ."\n" ;
	print "    Fields are: ". (join ';',
				 map ( $parser->{$_} ."(".
				       ( $parser->{$_} == -1 ? "d" : $field_letter[$parser->{$_}] )
				       .")" , (0..$j-1) )
				 )."\n" ;
    }

    return $parser ;
}

# user parsers
my @parsers = map ( generate_user_parser ($_), @format_strings ) ;

sub parse_file_with_user_parsers
{
    my $file = shift ;
    my $filename = shift ;
    my $tag_type = shift ;

    # try each format until one works
    foreach my $parser (@parsers) {
	print "  with format '". $parser->{title} ."'... " ;

	if ($filename =~ /^$parser->{regexp}$/) {
	    print "\n" ;
	    # try to tag, without confirmation
	    my $res = match_fields_with_parser ($file, $tag_type, $parser, 0,
						$TAG_MAY_PREFER|$TAG_MAY_SKIP_PARSER, @_) ;
	    if ($res == $TAG_SUCCESS || $res == $TAG_SUCCESS_PREFERRED || $res == $TAG_SKIP_FILE) {
		if ($res == $TAG_SUCCESS_PREFERRED) {
		    $preferred_parser = $parser ;
		}
		return $res ;
	    }
	    # try next parser
	    die "Unknown tag return value: $res.\n" if $res != $TAG_SKIP_PARSER ;

	} else {
	    print "Does not match.\n" ;
	}
    }
    return $TAG_NO_MATCH ;
}

#######################################################
# process files

while ( @files ) {
    my $file = shift @files ;
    my $res ;

    print "Processing file \"".$file."\"...\n" ;

    # removing path if asked, only in $filename, keep $file complete
    my $filename = $file ;
    if ($nopath_opt && $filename =~ /\//) {
	$filename =~ s/.*\/([^\/]+)/$1/ ;
    }

    # split into filename and extension
    my @parts = split (/\./, $filename) ;
    my $extension = pop @parts ;
    $filename = join (".", @parts) ;

    # split into filename and extension
    my $tag_type = $type_opt ;
    if (not defined $tag_type) {
	if ($extension =~ /$mp3_ext/i) {
	    $tag_type = $mp3_type ;
	} elsif ($extension =~ /$ogg_ext/i) {
	    $tag_type = $ogg_type ;
	} elsif ($extension =~ /$flac_ext/i) {
	    $tag_type = $flac_type ;
	} else {
	    print "  Skipping this unknown-type file '$file'\n" ;
	    goto NEXT_FILE ;
	}
    }

    # try the preferred parser first
    if (defined $preferred_parser) {
	if ($filename =~ /^$preferred_parser->{regexp}$/) {
	    $res = tag_with_parser ($file, $tag_type, $preferred_parser, 0, 0, @_) ;
	    # there can't be any confirmation here, SKIP is not possible
	    # only SUCCESS if possible
	    die "Unknown tag return value: $res.\n" if $res != $TAG_SUCCESS ;
	    goto NEXT_FILE ;
	} else {
	    print "  Preferred parser '$preferred_parser->{title}' does not match this file\n" ;
	    print "    Returning to original mode\n" ;
	    $current_ask_opt = $ask_opt ; $current_yes_opt = $yes_opt ;
	}
	$preferred_parser = undef ;
    }

    # try user provided parsers then
    $res = parse_file_with_user_parsers($file, $filename, $tag_type) ;
    goto NEXT_FILE if $res == $TAG_SUCCESS or $res == $TAG_SUCCESS_PREFERRED or $res == $TAG_SKIP_FILE ;

    # try to guess my internal format database then
    if ($guess_opt) {
	$res = parse_file_with_internal_parsers($file, $filename, $tag_type) ;
	goto NEXT_FILE if $res == $TAG_SUCCESS or $res == $TAG_SUCCESS_PREFERRED or $res == $TAG_SKIP_FILE ;
    }

    # tag with default values only
    my @field = @field_default ;
    $#field = $fields-1 ;
    if ($guess_opt or @parsers) {
	print "  Didn't find any parser!\n" ;
    }
    $res = confirm_fields ($file, $tag_type, 1, 0, @field) ;
    die "Unknown tag return value: $res.\n" if $res != $TAG_SUCCESS and $res != $TAG_SKIP_FILE ;

  NEXT_FILE:
    shift ;
}

#######################################################
# fields confirmation

sub confirm_letters {
    my $behaviors = shift ;
    my $string = "[Yv" ;
    $string .= "u" if $behaviors & $TAG_MAY_PREFER ;
    $string .= "ae" ;
    $string .= "n" if $behaviors & $TAG_MAY_SKIP_PARSER ;
    $string .= "p" if $behaviors & $TAG_MAY_SKIP_PATH_PARSER ;
    $string .= "s,(h)elp]" ;
    return $string ;
}

sub confirm_tag_usage {
    my $behaviors = shift ;
    print "    y => Yes, use this matching (default)\n" ;
    print "    v => View which fields were matched\n" ;
    print "    u => Use this format for all files until one does not match\n"
	if $behaviors & $TAG_MAY_PREFER ;
    print "    a => Always yes, stop asking for a confirmation\n" ;
    print "    e => Edit these fields by hand\n" ;
    print "    n => No, try the next matching format\n"
	if $behaviors & $TAG_MAY_SKIP_PARSER ;
    print "    p => No, try the next path matching format\n"
	if $behaviors & $TAG_MAY_SKIP_PATH_PARSER ;
    print "    s => Skip this file, don't process it\n" ;
    print "    h => Show this help\n" ;
}

sub confirm_fields {
    my $file = shift ;
    my $tag_type = shift ;
    my $confirm = shift ;
    my $behaviors = shift ;

    # remaining args are fields
    my @field ;
    for(my $i = 0; $i < $fields; $i++) {
	$field[$i] = shift;
    }

    # prefer this type of tagging ?
    my $preferred = 0 ;

    # confirm if required
    if ($current_ask_opt or ($confirm and !$current_yes_opt)) {
      ASK_CONFIRM:
	print "  Use this matching ".(confirm_letters ($behaviors))." ? " ;
	my $reply = <> ;
	chomp $reply ;
	if ($reply eq "" or $reply =~ /^y/i) {
	    goto TAG_IT ;
	} elsif ($reply eq "v") {
	    for(my $i = 0; $i < $fields; $i++) {
		print "    ".ucfirst($field_name[$i]).$field_trailing_spaces[$i].": ".$field[$i]."\n" if defined $field[$i] ;
	    }
	    goto ASK_CONFIRM ;
	} elsif ($reply =~ /^a/i) {
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto TAG_IT ;
	} elsif ($behaviors & $TAG_MAY_PREFER and $reply =~ /^u/i) {
	    $preferred = 1 ;
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto TAG_IT ;
	} elsif ($behaviors & $TAG_MAY_SKIP_PARSER and $reply =~ /^n/i) {
	    return $TAG_SKIP_PARSER ;
	} elsif ($behaviors & $TAG_MAY_SKIP_PATH_PARSER and $reply =~ /^p/i) {
	    return $TAG_SKIP_PATH_PARSER ;
	} elsif ($reply =~ /^s/i) {
	    return $TAG_SKIP_FILE ;
	} elsif ($reply =~ /^e/i) {

	    my @edit_field = @field ;
	    $#edit_field = $fields-1 ;
	  ASK_EDIT:
	    print "    Edit a field [atAngycEC,(h)elp] ? " ;
	    my $edit_reply = <> ;
	    chomp $edit_reply ;
	    if ($edit_reply =~ /^($field_letters)$/) {
		my $i = ( grep { $edit_reply eq $field_letter[$_] } ( 0 .. $fields-1 ) ) [0] ;
		print "      Enter ".ucfirst($field_name[$i])." field (" ;
		print "<enter> to keep '".$edit_field[$i]."', " if defined $edit_field[$i] ;
		print "CLEAR to clear): " ;
		my $val = <> ;
		chomp $val ;
		if ($val) {
		    $val = "" if $val eq "CLEAR" or $val eq "<CLEAR>" ;
		    $edit_field[$i] = $val ;
		}
		goto ASK_EDIT ;
	    } elsif ($edit_reply eq "E") {
		@field = @edit_field ;
		goto TAG_IT ;
	    } elsif ($edit_reply eq "C") {
		goto ASK_CONFIRM ;
	    } else {
		for(my $i = 0; $i < $fields; $i++) {
		    my $val = $edit_field[$i];
		    if (not defined $val) {
			$val = "<not defined>" ;
		    } elsif ($val eq "") {
			$val = "<CLEAR>" ;
		    } else {
			$val = "'".$val."'" ;
		    }
		    print "      ".$field_letter[$i]
			." => Edit ".ucfirst($field_name[$i]).$field_trailing_spaces[$i]
			." (=".$val.")\n" ;
		}
		print "      E => End edition and process the file\n" ;
		print "      C => Cancel edition\n" ;
		goto ASK_EDIT ;
	    }

	} else {
	    confirm_tag_usage ($behaviors) ;
	    goto ASK_CONFIRM ;
	}
    }

  TAG_IT:
    my $res = tag_with_fields ($file, $tag_type, @field) ;
    return $TAG_SUCCESS_PREFERRED if $preferred and $res == $TAG_SUCCESS ;
    return $res ;
}

sub match_fields_with_parser {
    my $file = shift ;
    my $tag_type = shift ;
    my $parser = shift ;
    my $confirm = shift ;
    my $behaviors = shift ;

    # get default fields (without modifying the original)
    my @field = @field_default ;
    $#field = $fields-1 ;

    # set to 1 when the field is defined (not by default)
    my @field_set = () ;
    $#field_set = $fields-1 ;

    # get fields and show them if asked
    my $i = 1 ;
    while ( $i <= $parser->{indices} ) {
        my $indice = $parser->{$i-1};
	if ( $indice >= 0 ) {
	    my $val = ${$i} ;
	    $val =~ s/\b(.)/uc $1/eg if $maj_opt ;
	    $val =~ s/($sep_opt)/ /g if defined $sep_opt ;
	    if ($field_set[$indice]) {
		print "    WARNING: ".ucfirst($field_name[$indice])." already set to '".$field[$indice]
		    ."', skipping new value '$val'.\n" if ($field[$indice] ne $val) ;
		goto NEXT_FIELD ;
	    }
	    $field[$indice] = $val ;
	    $field_set[$indice] = 1 ;
	    if ($verbose_opt or $confirm or $current_ask_opt) {
		print "    ". ucfirst($field_name[$indice])
		    .$field_trailing_spaces[$indice]
		    .": ". $val ."\n" ;
	    }
	}
     NEXT_FIELD:
	$i++ ;
    }

    return confirm_fields ($file, $tag_type, $confirm, $behaviors, @field) ;
}

#######################################################
# tagging

sub mp3_tagging_system_args {
    my @field = @_ ;
    my @field_mp3info_option = ('a', 't', 'l', 'n', 'g', 'y', 'c') ;
    my @mp3_tagging_cmd = ( 'mp3info' ) ;
    my @mp3_tagging_clear_option = map { ( "-".$field_mp3info_option[$_] , "" ) } ( 0 .. $fields-1 ) ;
    # append is not supported by id3 tags

    return ( @mp3_tagging_cmd ,
	     $clear_opt ? @mp3_tagging_clear_option : () ,
	     ( map { ( "-".$field_mp3info_option[$_] , $field[$_] ) }
	       ( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
	       ) ,
	     ) ;
}

sub ogg_tagging_system_args {
    my @field = @_ ;
    my @field_vorbiscomment_option = ('ARTIST', 'TITLE', 'ALBUM', 'TRACKNUMBER', 'GENRE', 'DATE', 'COMMENT') ;
    my @ogg_tagging_cmd = ( 'vorbiscomment', '-q' ) ;
    my @ogg_tagging_clear_option = ( '-w' ) ;
    my @ogg_tagging_append_option = ( '-a' ) ;

    return ( @ogg_tagging_cmd ,
	     $append_opt ? @ogg_tagging_append_option : @ogg_tagging_clear_option ,
	     ( map { ( "-t" , $field_vorbiscomment_option[$_]."=".$field[$_] ) }
	       ( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
	       ) ,
	     ) ;
}

sub flac_tagging_system_args {
    my @field = @_ ;
    my @field_metaflac_option = ('ARTIST', 'TITLE', 'ALBUM', 'TRACKNUMBER', 'GENRE', 'DATE', 'COMMENT') ;
    my @flac_tagging_cmd = ( 'metaflac' ) ;
    my @flac_tagging_clear_option = ( '--remove-all-tags' ) ;

    return (@flac_tagging_cmd ,
	    $clear_opt ? @flac_tagging_clear_option : () ,
	    !$append_opt ? ( map { ( "--remove-tag", $field_metaflac_option[$_] ) }
			     ( grep { defined $field[$_] } ( 0 .. $fields-1 ) ) ) : () ,
	    ( map { ( "--set-tag", $field_metaflac_option[$_]."=".$field[$_] ) }
	      ( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
	      ) ,
	    ) ;
}

sub tag_with_fields {
    my $file = shift ;
    my $tag_type = shift ;

    # remaining args are fields
    my @field ;
    for(my $i = 0; $i < $fields; $i++) {
	$field[$i] = shift;
    }

    # do we have to tag ?
    goto SUCCESS
	if $no_tagging_opt ;

    # is there actually something to do ?
    if ( ! grep { defined $field[$_] } ( 0 ... $fields-1 ) ) {
	print "    Nothing to do.\n" ;
	goto SUCCESS ;
    }

    # tagging command line
    my @system_args ;
    if ($tag_type eq $mp3_type) {
	@system_args = ( (mp3_tagging_system_args @field), $file) ;
    } elsif ($tag_type eq $ogg_type) {
	@system_args = ( (ogg_tagging_system_args @field), $file) ;
    } elsif ($tag_type eq $flac_type) {
	@system_args = ( (flac_tagging_system_args @field), $file) ;
    }

    # show command line and really tag if asked
    if ($dry_run_opt or $verbose_opt) {
	print "      ". +(join "' '", @system_args) ."\n" ;
    }
    if (!$dry_run_opt) {
	print "    Tagging.\n" ;
	my ($status, @output) = system_with_output @system_args ;
	if ($status) {
	    print "      Tagging failed, command line was: ". join (" ", @system_args) ."\n" ;
	    while (my $line = shift @output) {
		print "# $line" ;
	    }
	}
    }

  SUCCESS:
    if (defined $rename_opt) {
	rename_with_tags ($file, $tag_type, @field) ;
    }

    return $TAG_SUCCESS ;
}

#############################################
# renaming

sub confirm_rename_usage {
    my $behaviors = shift ;
    print "      y => Yes, rename this file (default)\n" ;
    print "      a => Always rename without asking\n" ;
    print "      e => Edit the filename before tagging\n" ;
    print "      n => No, don't rename this file\n" ;
    print "      h => Show this help\n" ;
}

sub rename_with_tags {
    my $file = shift ;
    my $tag_type = shift ;
    my $undefined = 0 ;

    print "  Renaming with format '$rename_opt'...\n" ;
    # remaining args are fields
    my @field ;
    for(my $i = 0; $i < $fields; $i++) {
	my $val = shift ;
	if (defined $val) {
	    $val = lc ($val)
		if $rename_min_opt ;
	    $val =~ s/ /$rename_sep_opt/g
		if $rename_sep_opt ;
	}
	$field[$i] = $val ;
    }

    my $format_string = $rename_opt ;
    my @array = split(//, $format_string) ;
    for(my $i = 0; $i < @array - 1; $i++) {

	# normal characters
	next if $array[$i] ne "%" ;

	# remove % and check next char
	splice (@array, $i, 1) ;
	# replace the char with the matching
	my $char = $array[$i] ;
	next if $char eq "%" ;
	if ($char =~ /$field_letters/) {
	    my $letter = $array[$i] ;
	    my @indices = grep { $char eq $field_letter[$_] } ( 0 .. $fields-1 ) ;
	    my $val = $field[$indices[0]] ;
	    if (not defined $val) {
		$undefined++ ;
		print "    WARNING: Undefined field '".$field_name[$indices[0]]."'.\n" ;
		$val = "" ;
	    }
	    if ($char eq 'n') {
		# initialize track number to 0 if empty
		$val = "0" if !$val ;
		# make it at least 2 digits
		$val = '0'.$val if $val < 10 and length $val < 2 ;
	    }
	    $array[$i] = $val ;
	} else {
	    $array[$i] = "%".$char ;
	}
    }

    my $new_name = join ("", @array) ;
    if (!$rename_ext_opt) {
	if ($tag_type eq $mp3_type) {
	    $new_name .= ".". $mp3_ext ;
	} elsif ($tag_type eq $ogg_type) {
	    $new_name .= ".". $ogg_ext ;
	} elsif ($tag_type eq $flac_type) {
	    $new_name .= ".". $flac_ext ;
	}
    }

    print "    New filename is '$new_name'\n" ;

    # confirm if required or if any field undefined
    if ($undefined or !$current_rename_yes_opt) {
      ASK_CONFIRM:
	print "    Really rename the file [Yaen,(h)elp] ? " ;
	my $reply = <> ;
	chomp $reply ;
        if ($reply eq "" or $reply =~ /^y/i) {
            goto RENAME_IT ;
	} elsif ($reply =~ /^a/i) {
	    $current_rename_yes_opt = 1 ;
            goto RENAME_IT ;
	} elsif ($reply =~ /^n/i) {
	    return ;
	} elsif ($reply =~ /^e/i) {
	    print "      Enter new filename: " ;
	    $new_name = <> ;
	    chomp $new_name ;
	    goto ASK_CONFIRM ;
	} else {
	    confirm_rename_usage ;
	    goto ASK_CONFIRM ;
	}
    }

  RENAME_IT:
    if ($new_name eq $file) {
	print "    Filename would not change, not renaming\n" ;
	return ;
    }

    return
	if $dry_run_opt ;

    my $remain = $new_name ;
    my $path = '' ;
    while ($remain =~ /^([^\/]*\/+)(.*)$/) {
        $path .= $1 ;
	$remain = $2 ;
	if (!-d $path) {
	    print "      Creating directory '$path'\n" ;
	    if (!mkdir $path) {
		print "      ERROR: Failed to create directory ($!)\n" ;
		return ;
	    }
	}
    }

    print "    Renaming.\n" ;
    rename $file, $new_name
	or print "    ERROR: Failed to rename ($!)\n" ;
}

#############################################
# generate configuration file

sub generate_config {
    my $file = shift ;
    die "Cannot generate $file which already exists."
        if -e "$file" ;
    open NEWCFG, ">$file"
        or die "Cannot open $file ($!).\n" ;

    print NEWCFG "# This is a lltag configuration file.\n" ;
    print NEWCFG "# It was automatically generated.\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;

    map { print NEWCFG "format = \"$_\"\n" ; } @format_strings ;

    print NEWCFG "guess = $guess_opt\n" ;
    print NEWCFG "nopath = $nopath_opt\n" ;

    map { print NEWCFG "default_$field_name[$_] = \"$field_default[$_]\"\n" ; }
	(grep { defined $field_default[$_] } (0 .. $fields-1 )) ;

    print NEWCFG "spaces = $spaces_opt\n" ;
    print NEWCFG "maj = $maj_opt\n" ;
    print NEWCFG "sep = \"$sep_opt\"\n"
	if defined $sep_opt ;
    print NEWCFG "type = ". (defined $type_opt?$type_opt:"none") ."\n" ;
    print NEWCFG "clear_tags = $clear_opt\n" ;
    print NEWCFG "append_tags = $append_opt\n" ;
    print NEWCFG "no_tagging = $no_tagging_opt\n" ;

    print NEWCFG "rename_format = \"" .($rename_opt?$rename_opt:""). "\"\n" ;
    print NEWCFG "rename_min = $rename_min_opt\n" ;
    print NEWCFG "rename_sep = \"$rename_sep_opt\"\n" ;
    print NEWCFG "rename_ext = $rename_ext_opt\n" ;

    print NEWCFG "dry_run = $dry_run_opt\n" ;
    print NEWCFG "yes = $yes_opt\n" ;
    print NEWCFG "ask = $ask_opt\n" ;
    print NEWCFG "recursive = $recursive_opt\n" ;
    print NEWCFG "verbose = $verbose_opt\n" ;

    close NEWCFG ;
}

generate_config $gencfg_file
    if defined $gencfg_file ;
