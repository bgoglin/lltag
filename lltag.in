#!/usr/bin/perl -w

use strict ;

require Lltag::Tags ;
require Lltag::Misc ;
require Lltag::MP3 ;
require Lltag::OGG ;
require Lltag::FLAC ;
require Lltag::CDDB ;
require Lltag::Parse ;
require Lltag::Rename ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

#######################################################
# main hash for globals and config
my $self = {} ;

#######################################################
# configuration file location
$self->{common_lltag_dir} = "@SYSCONFDIR@/lltag" ;
$self->{user_lltag_dir} = "$ENV{HOME}/.lltag" ;
$self->{lltag_format_filename} = "formats" ;
$self->{lltag_config_filename} = "config" ;
$self->{lltag_edit_history_filename} = "edit_history" ;

#######################################################
Lltag::Misc::init_readline ($self) ;

#######################################################
# format parameters

@{$self->{field_names}} = ('ARTIST', 'TITLE', 'ALBUM', 'NUMBER', 'GENRE', 'DATE', 'COMMENT') ;
@{$self->{field_letters}} = ('a', 't', 'A', 'n', 'g', 'd', 'c') ;

%{$self->{field_name_letter}} =
    (
     'ARTIST'  => 'a',
     'TITLE'   => 't',
     'ALBUM'   => 'A',
     'NUMBER'  => 'n',
     'GENRE'   => 'g',
     'DATE'    => 'd',
     'COMMENT' => 'c',
     ) ;

%{$self->{field_name_trailing_spaces}} =
    (
     'ARTIST' => '  ',
     'TITLE' => '   ',
     'ALBUM' => '   ',
     'NUMBER' => '  ',
     'GENRE' => '   ',
     'DATE' => '    ',
     'COMMENT' => ' ',
     ) ;

%{$self->{field_default}} = () ;

%{$self->{additional_values}} = () ;

%{$self->{field_letter_name}} =
    (
     'a' => 'ARTIST',
     't' => 'TITLE',
     'A' => 'ALBUM',
     'n' => 'NUMBER',
     'g' => 'GENRE',
     'd' => 'DATE',
     'c' => 'COMMENT',
     ) ;

# change format names into a parsing string
$self->{field_letters_union} = (join '|', @{$self->{field_letters}}) ;

#######################################################
# version
my $version = "@VERSION@" ;

sub version {
    print "This is lltag version $version.\n" ;
    exit 0 ;
}

#######################################################
# usage
sub usage {
    print $0." $version is a frontend to tag MP3/OGG/FLAC files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print " Tagging options:\n" ;
    print "  -F, --format <format>  Try format (multiple instances allowed)\n" ;
    print "  -G, --guess            Guess format (default)\n" ;
    print "  -C, --cddb             Query tags in CDDB\n" ;
    print "  -p, --nopath           Remove the path from filenames when matching\n" ;
    print map { "  -". $self->{field_name_letter}{$_} .", --". $_.$self->{field_name_trailing_spaces}{$_}
		    ."<val>    Set the default value for ". ucfirst($_) ."\n" } @{$self->{field_names}} ;
    print "  --tag <TAG=value>      Add <value> to tag <TAG>\n" ;
    print "  --spaces               Allow no or multiple spaces\n" ;
    print "  --maj                  Upcase first letters of words in tags\n" ;
    print "  --sep <s1|s2|...>      Replace |-separated strings with space in tags\n" ;
    print "  --regexp <regexp>      Apply a replace regexp to tags before tagging\n" ;
    print "  --mp3/--ogg/--flac     Force mp3, ogg of flac instead of by-extension detection\n" ;
    print "  --clear                Clear all tags of audio files when possible\n" ;
    print "  --append               Append tags only instead of replacing old ones when possible\n" ;
    print "  --no-tagging           Do not actually tag files\n" ;
    Lltag::Rename::rename_usage ($self) ;
    print " General options:\n" ;
    print "  --dry-run              Do nothing but show what would have been done\n" ;
    print "  --yes                  Tag without asking for confirmation when guessing\n" ;
    print "                         Rename without asking for confirmation\n" ;
    print "  --ask                  Always ask for confirmation before tagging\n" ;
    print "  -R, --recursive        Recursively search all files in subdirectories\n" ;
    print "  -v, --verbose          Verbose messages\n" ;
    print "  --config <file>        Read additional configuration file\n" ;
    print "  --gencfg <file>        Generate additional configuration file\n" ;
    print " Behavior options:\n" ;
    print "  -S                     Show all tags from files\n" ;
    print "  --show-tags <tag,..>   Show several tags from files\n" ;
    print "  -L, --list             List internal formats\n" ;
    print "  -V, --version          Show lltag version\n" ;
    print "  -h, --help             Show this help\n" ;
    Lltag::Parse::parsing_usage ($self) ;
    print "\n" ;
    print "Author:    Brice Goglin\n" ;
    print "Homepage:  http://home.gna.org/lltag\n" ;
    print "Report bugs to:  <lltag-users AT gna.org>\n" ;
    exit 1;
}

#######################################################
# globals

my $mp3_type = "mp3" ;
my $ogg_type = "ogg" ;
my $flac_type = "flac" ;

my $mp3_ext = "mp3" ;
my $ogg_ext = "ogg" ;
my $flac_ext = "flac" ;

#######################################################
# options

$self->{dry_run_opt} = 0 ;
$self->{verbose_opt} = 0 ;
$self->{recursive_opt} = 0 ;
$self->{list_formats_opt} = 0 ;
$self->{show_tags_opt} = "" ;
$self->{no_tagging_opt} = 0 ;

%{$self->{additional_values}} = () ;
@{$self->{additional_tags}} = () ;

$self->{ask_opt} = 0 ;
$self->{guess_opt} = 0 ;
$self->{cddb_opt} = 0 ;
$self->{nopath_opt} = 0 ;
$self->{maj_opt} = 0 ;
$self->{sep_opt} = undef ;
$self->{spaces_opt} = 0 ;
$self->{type_opt} = undef ;
$self->{yes_opt} = 0 ;
$self->{clear_opt} = 0 ;
$self->{append_opt} = 0 ;
@{$self->{regexp_opts}} = () ;

$self->{rename_opt} = undef ;
$self->{rename_min_opt} = 0 ;
$self->{rename_sep_opt} = " " ;
$self->{rename_ext_opt} = 0 ;
@{$self->{rename_regexp_opts}} = () ;

$self->{gencfg_file} = undef ;

@{$self->{user_format_strings}} = () ;

$self->{cddb_server_name} = "www.freedb.org" ;
$self->{cddb_server_port} = 80 ;
$self->{cddb_proxy_name} = undef ;
$self->{cddb_proxy_port} = undef ;

#######################################################
# parse config files first

my @additional_config_files = () ;

# process these options but kept other options in @ARGV for later
Getopt::Long::Configure('passthrough') ;
GetOptions(
	   'config=s'     => \@additional_config_files,
        ) ;

# restore default behavior: process all options and warn on error
Getopt::Long::Configure('nopassthrough') ;

sub process_option {
    $_ = shift ;
    chomp $_ ;
    if (/^format\s*=\s*"(.+)"$/) {
	push (@{$self->{user_format_strings}}, $1) ;
    } elsif (/^guess\s*=\s*(.+)$/) {
	$self->{guess_opt} = $1 ;
    } elsif (/^nopath\s*=\s*(.+)$/) {
	$self->{nopath_opt} = $1 ;
    } elsif (/^default_([^ ]*)\s*=\s*"(.*)"$/) {
        die "Unrecognized option line #$.: \"$_\"\n"
	    # TODO: drop non-capitalized field name support on september 20 2006
	    unless defined $self->{field_name_letter}{uc ($1)} ;
	# TODO: drop filename support on september 20 2006
	$self->{field_default}{uc ($1)} = $2 ;
    } elsif (/^tag\s*=\s*"(.+)"$/) {
	push @{$self->{additional_tags}}, $1 ;
    } elsif (/^spaces\s*=\s*(.+)$/) {
	$self->{spaces_opt} = $1 ;
    } elsif (/^maj\s*=\s*(.+)$/) {
	$self->{maj_opt} = $1 ;
    } elsif (/^sep\s*=\s*"(.*)"$/) {
	$self->{sep_opt} = $1 ;
    } elsif (/^type\s*=\s*(.+)$/) {
	if ($1 eq "none") {
	    $self->{type_opt} = undef ;
	} elsif ($1 ne $mp3_type and $1 ne $ogg_type and $1 ne $flac_type) {
	    die "Unrecognized type '$1' line #$\n" ;
	} else {
	    $self->{type_opt} = $1 ;
	}
    } elsif (/^regexp\s*=\s*"(.+)"$/) {
	push (@{$self->{regexp_opts}}, $1) ;
    } elsif (/^clear_tags\s*=\s*(.+)$/) {
	$self->{clear_opt} = $1 ;
    } elsif (/^append_tags\s*=\s*(.+)$/) {
	$self->{append_opt} = $1 ;
    } elsif (/^no_tagging\s*=\s*(.+)$/) {
	$self->{no_tagging_opt} = $1 ;
    } elsif (/^rename_format\s*=\s*"(.*)"$/) {
	if ($1 eq "") {
	    $self->{rename_opt} = undef ;
	} else {
	    $self->{rename_opt} = $1 ;
	}
    } elsif (/^rename_min\s*=\s*(.+)$/) {
	$self->{rename_min_opt} = $1 ;
    } elsif (/^rename_sep\s*=\s*"(.*)"$/) {
	$self->{rename_sep_opt} = $1 ;
    } elsif (/^rename_regexp\s*=\s*"(.+)"$/) {
	push (@{$self->{rename_regexp_opts}}, $1) ;
    } elsif (/^rename_ext\s*=\s*(.+)$/) {
	$self->{rename_ext_opt} = $1 ;
    } elsif (/^dry_run\s*=\s*(.+)$/) {
	$self->{dry_run_opt} = $1 ;
    } elsif (/^yes\s*=\s*(.+)$/) {
	$self->{yes_opt} = $1 ;
	$self->{ask_opt} = 0 if $1 ;
    } elsif (/^ask\s*=\s*(.+)$/) {
	$self->{ask_opt} = $1 ;
	$self->{yes_opt} = 0 if $1 ;
    } elsif (/^recursive\s*=\s*(.+)$/) {
	$self->{recursive_opt} = $1 ;
    } elsif (/^verbose\s*=\s*(.+)$/) {
	$self->{verbose_opt} = $1 ;
    } elsif (/^cddb\s*=\s*(.+)$/) {
	$self->{cddb_opt} = $1 ;
    } elsif (/^cddb_server_name\s*=\s*"(.+)"$/) {
	$self->{cddb_server_name} = $1 ;
    } elsif (/^cddb_server_port\s*=\s*(\d+)$/) {
	$self->{cddb_server_port} = $1 ;
    } elsif (/^cddb_proxy_name\s*=\s*"(.*)"$/) {
	$self->{cddb_proxy_name} = $1 ;
    } elsif (/^cddb_proxy_port\s*=\s*(\d*)$/) {
	$self->{cddb_proxy_port} = $1 ;
# Error
    } elsif (/^[^#]/ && !/^(\s*)$/) {
        die "Unrecognized option line #$.: \"$_\"\n" ;
    }
}

sub parse_generic_config_file {
    my $file = shift ;
    open CONF, $file
        or return ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

parse_generic_config_file "$self->{common_lltag_dir}/$self->{lltag_config_filename}" ;
parse_generic_config_file "$self->{user_lltag_dir}/$self->{lltag_config_filename}" ;

sub parse_additional_config_file {
    my $file = shift ;
    open CONF, $file
        or die "Failed to open additional configuration file '$file' ($!).\n" ;
    while (<CONF>) {
        process_option $_ ;
    }
   close CONF ;
}

foreach my $file (@additional_config_files) {
    parse_additional_config_file $file ;
}

#######################################################
# parse cmdline options

# parse options
GetOptions(
	   'F|format=s'   => \@{$self->{user_format_strings}},
	   'G|guess'      => \$self->{guess_opt},
	   'C|cddb'       => \$self->{cddb_opt},
	   'p|nopath'     => \$self->{nopath_opt},
	   'spaces'       => \$self->{spaces_opt},
	   'maj'          => \$self->{maj_opt},
	   'sep=s'        => \$self->{sep_opt},
	   'regexp=s'     => \@{$self->{regexp_opts}},
	   'mp3'          => sub { $self->{type_opt} = $mp3_type ; },
	   'ogg'          => sub { $self->{type_opt} = $ogg_type ; },
	   'flac'         => sub { $self->{type_opt} = $flac_type ; },
	   'clear'        => \$self->{clear_opt},
	   'append'       => \$self->{append_opt},
	   'no-tagging'   => \$self->{no_tagging_opt},
	   'rename=s'     => \$self->{rename_opt},
	   'rename-min'   => \$self->{rename_min_opt},
	   'rename-sep=s' => \$self->{rename_sep_opt},
	   'rename-regexp=s' => \@{$self->{rename_regexp_opts}},
	   'rename-ext'   => \$self->{rename_ext_opt},
	   'dry-run'      => \$self->{dry_run_opt},
	   'R|recursive'  => \$self->{recursive_opt},
	   'yes'          => sub { $self->{yes_opt} = 1 ; $self->{ask_opt} = 0 ; },
	   'ask'          => sub { $self->{ask_opt} = 1 ; $self->{yes_opt} = 0 ; },
	   'v|verbose'    => \$self->{verbose_opt},
	   'gencfg=s'     => \$self->{gencfg_file},
	   'h|help'       => sub { usage () ; },
	   'V|version'    => sub { version () ; },
	   'L|list'       => \$self->{list_formats_opt},
	   'show-tags=s'  => \$self->{show_tags_opt},
	   'S'            => sub { $self->{show_tags_opt} = "all" ; },
	   'tag=s'        => \@{$self->{additional_tags}},
	   map { my $field = $_ ;
		 # use a sub because \$self->{field_default}{$field} always allocates it and assigns it to undef...
		 $self->{field_name_letter}{$field} .'|'. $field .'=s' => sub { shift ; $self->{field_default}{$field} = shift },
	       } @{$self->{field_names}} ,
	   ) or usage () ;

# yes/ask option status may vary with user confirmation replies
$self->{current_yes_opt} = $self->{yes_opt} ;
$self->{current_ask_opt} = $self->{ask_opt} ;

# confirmation when renaming
$self->{current_rename_yes_opt} = $self->{yes_opt} ;

# if no user parsers, no defaults, no guess and no cddb, force guess
$self->{try_internals_opt} = 1
    if $self->{guess_opt} or ( !@{$self->{user_format_strings}}
			       and !(grep { defined $self->{field_default}{$_} } (keys %{$self->{field_default}}))
			       and !$self->{list_formats_opt} ) ;

Lltag::Parse::init_parsing ($self) ;

#######################################################
# extract file type and parsename

sub extract_parsename_and_type {
    my $file = shift ;

    # split into parsename and extension, and remove the path if asked
    my @parts = split (/\./, $file) ;
    my $extension = pop @parts ;
    my $parsename = join (".", @parts) ;
    if ($self->{nopath_opt}) {
	my @parts = split (/\//, $parsename) ;
	$parsename = pop @parts ;
    }

    my $file_type = $self->{type_opt} ;
    if (not defined $self->{type_opt}) {
    # if not forced, get the type from the extension
	if ($extension =~ /$mp3_ext/i) {
	    $file_type = $mp3_type ;
	} elsif ($extension =~ /$ogg_ext/i) {
	    $file_type = $ogg_type ;
	} elsif ($extension =~ /$flac_ext/i) {
	    $file_type = $flac_type ;
	}
    }

    return ($parsename, $file_type) ;
}

#######################################################
# show existing tags if --show-tags was passed

sub read_tags {
    my $file = shift ;
    my $file_type = shift ;

    # extract tags as a stream
    my $status ;
    my @output ;
    if ($file_type eq $mp3_type) {
	($status, @output) = Lltag::MP3::read_tags ($self, $file) ;
    } elsif ($file_type eq $ogg_type) {
	($status, @output) = Lltag::OGG::read_tags ($self, $file) ;
    } elsif ($file_type eq $flac_type) {
	($status, @output) = Lltag::FLAC::read_tags ($self, $file) ;
    }
    if ($status) {
	print "  Failed to get tags from file.\n" ;
	next ;
    }

    # extract tags from the stream
    my $values = {} ;
    while (my $line = shift @output) {
	chomp $line ;
	my ($field, $value) = ($line =~ /^(.*)=(.*)$/) ;
	next if !$value ;
	Lltag::Tags::append_tag_value ($self, $values, $field, $value) ;
    }

    return $values ;
}

#######################################################
# apply user-given regexp

sub apply_regexp_to_tag {
    my $val = shift ;
    my $regexp = shift ;
    my $tag = shift ;

    # parse the regexp
    if ($regexp =~ /(?:([^:]+):)?s\/([^\/]+)\/([^\/]*)\/$/) {
	my @tags = () ;
	@tags = split (/,/, $1) if $1;
	my $from = $2 ;
	my $to = $3 ;
	$val =~ s/$from/$to/g
	    if !@tags or grep { $tag eq $_ } @tags ;
    } else {
	die "Unrecognized user regexp '$regexp'.\n" ;
    }

    return $val ;
}

#######################################################
# real tagging

sub tag_with_values {
    my $file = shift ;
    my $file_type = shift ;
    my $values = shift ;

    # is there actually something to do ?
    if ( !(keys %{$values}) ) {
	print "  Nothing to do.\n" ;
	return ;
    }

    # tagging command line
    my @system_args ;
    if ($file_type eq $mp3_type) {
	@system_args = ( (Lltag::MP3::tagging_system_args ($self, $values)), $file) ;
    } elsif ($file_type eq $ogg_type) {
	@system_args = ( (Lltag::OGG::tagging_system_args ($self, $values)), $file) ;
    } elsif ($file_type eq $flac_type) {
	@system_args = ( (Lltag::FLAC::tagging_system_args ($self, $values)), $file) ;
    }

    # show command line and really tag if asked
    if ($self->{dry_run_opt} or $self->{verbose_opt}) {
	print "  '". +(join "' '", @system_args) ."'\n" ;
    }
    if (!$self->{dry_run_opt}) {
	print "  Tagging.\n" ;
	my ($status, @output) = Lltag::Misc::system_with_output (@system_args) ;
	if ($status) {
	    print "    Tagging failed, command line was: ". join (" ", @system_args) ."\n" ;
	    while (my $line = shift @output) {
		print "# $line" ;
	    }
	}
    }
}

#######################################################
# main process

# read internal parsers
Lltag::Parse::read_internal_parsers ($self)
    if $self->{try_internals_opt} or $self->{list_formats_opt} ;

# if -L was passed, show formats and exit
if ($self->{list_formats_opt}) {
    print "Listing internal parsers:\n" ;
    Lltag::Parse::list_internal_parsers () ;
    exit 0 ;
}

# read additional tags
Lltag::Tags::get_additional_tag_values ($self) ;

# process remaining command-line arguments as files
my @files = () ;
while ( @ARGV ) {
    if ($self->{recursive_opt}) {
	my $dir = shift @ARGV ;
	open FIND, "find \"$dir\" |" ;
	my @dirfiles = <FIND> ;
	close FIND ;
	foreach my $file (@dirfiles) {
	    chomp $file ;
	    if (-f $file) {
		push (@files, $file) ;
	    }
	}
    } else {
	my $file = shift @ARGV ;
	if (-f $file) {
	    push (@files, $file) ;
	} else {
	    print "Skipping the non-file '$file'\n" ;
	}
    }
}

# display tags
if ($self->{show_tags_opt}) {
    my @fields_to_show = split (/,/, $self->{show_tags_opt}) ;
    foreach my $file (@files) {
	print "$file:\n"
	    if @files ;

	my ($parsename, $file_type) = extract_parsename_and_type $file ;
	if (not defined $file_type) {
	    print "  Skipping this unknown-type file.\n" ;
	    next ;
	}

	my $values = read_tags $file, $file_type ;

	foreach my $field (@{$self->{field_names}}, (Lltag::Tags::get_values_non_regular_keys ($self, $values))) {
	    next if not defined $values->{$field} ;
	    next unless grep { /^all$/ } @fields_to_show
		or grep { /^$field$/i } @fields_to_show ;
	    map { print "  $field=$_\n" } (Lltag::Tags::get_tag_value_array ($self, $values, $field)) ;
	}
    }

    exit 0 ;
}

# generate user parsers
Lltag::Parse::generate_user_parsers ($self) ;

# main reading/parsing/tagging/renaming loop
while ( @files ) {
    my $file = shift @files ;
    my $values = undef ;
    my $new_values = undef ;
    my $res ;

    print "\n" ;
    print "Processing file \"".$file."\"...\n" ;

    my ($parsename, $file_type) = extract_parsename_and_type $file ;
    if (not defined $file_type) {
	print "  Skipping this unknown-type file '$file'\n" ;
	goto NEXT_FILE ;
    }

    # read old tags
    my $old_values = read_tags $file, $file_type ;

    # FIXME: parse first, to get the track number?

    my $first_round = 1 ;
    while (1) {

	# try preferred parser first
	($res, $values) = Lltag::Parse::try_to_parse_with_preferred ($self, $file, $parsename, $file_type) ;
	goto ADD_DEFAULTS
	    if $res == Lltag::Parse->PARSE_SUCCESS ;
	die "Unknown tag return value: $res.\n"
	    unless $res == Lltag::Parse->PARSE_NO_MATCH ;

	# try CDDB, if enabled
	if ($self->{cddb_opt}) {
      TRY_CDDB:
	    ($res, $values) = Lltag::CDDB::get_cddb_tags ($self) ;
	    goto ADD_DEFAULTS
		if $res == Lltag::CDDB->CDDB_SUCCESS ;
	    die "Unknown CDDB return value: $res.\n"
		unless $res == Lltag::CDDB->CDDB_ABORT ;
	    # during first round, try parse before going to confirmation
	    # FIXME: option to disable parsing ?
	    goto ADD_DEFAULTS
		unless $first_round ;
	}

	# try to parse this file
      TRY_PARSE:
	($res, $values) = Lltag::Parse::try_to_parse ($self, $file, $parsename, $file_type) ;
	goto ADD_DEFAULTS
	    if $res == Lltag::Parse->PARSE_SUCCESS or $res == Lltag::Parse->PARSE_SUCCESS_PREFERRED ;
	die "Unknown tag return value: $res.\n"
	    unless $res == Lltag::Parse->PARSE_NO_MATCH or $res == Lltag::Parse->PARSE_ABORT ;

      ADD_DEFAULTS:
	$first_round = 0;

	# add defaults
	foreach my $field (@{$self->{field_names}}) {
	    $values->{$field} = $self->{field_default}{$field} if not defined $values->{$field} and defined $self->{field_default}{$field} ;
	}

      CONFIRM:
	print "    Current tag values are:\n" ;
	foreach my $field (@{$self->{field_names}}) {
	    print "      ".ucfirst($field).$self->{field_name_trailing_spaces}{$field}.": ".$values->{$field}."\n"
		if defined $values->{$field} ;
	}

	goto TAG
	    if $self->{current_yes_opt} and !$self->{current_ask_opt} ;

	while (1) {
	    Lltag::Misc::print_question ("  Use these tag values [<y>aPCEDsQ] ? ") ;
	    my $confirm_reply = <> ;
	    chomp $confirm_reply ;

	    # FIXME: option to display old values

	    # FIXME: option to display additonial values

	    goto TAG
		# FIXME: check confirm options and always, except if cddb
		if $confirm_reply eq "y" or $confirm_reply eq "" ;
	    goto TRY_PARSE
		if $confirm_reply eq "P" ;
	    goto TRY_CDDB
		if $confirm_reply eq "C" ;
	    goto NEXT_FILE
		if $confirm_reply eq "s" ;

	    goto EXIT
		if $confirm_reply eq "Q" ;

	    if ($confirm_reply =~ /^a/i) {
		$self->{current_ask_opt} = 0 ; $self->{current_yes_opt} = 1 ;
		goto TAG ;
	    } elsif ($confirm_reply eq "E") {
		$values = Lltag::Tags::edit_values ($self, $values, $self->{field_names}) ;
		goto CONFIRM ;

	    } elsif ($confirm_reply eq "D") {
		$values = undef ;
		goto ADD_DEFAULTS ;

	    } else {
		print "    y => Yes, use these tags (default)\n" ;
		print "    a => Always yes, stop asking for a confirmation\n" ;
		print "    P => Try to parse the file\n" ;
		print "    C => Query CDDB\n" ;
		print "    E => Edit values\n" ;
		print "    D => Only use default values\n" ;
		print "    s => Skip this file\n" ;
		print "    Q => Quit without tagging anything anymore\n" ;
		print "    h => Show this help\n" ;
	    }
	}

    }

  TAG:
    # FIXME: do that before confirmation

    # add new values to the old ones, depending on clear/append options
    $new_values = Lltag::Tags::append_tag_values ($self, $old_values, $values) ;

    # append additional tags too
    $new_values = Lltag::Tags::append_tag_values ($self, $new_values, $self->{additional_values}) ;

    # actually tagging
    tag_with_values $file, $file_type, $new_values
	unless $self->{no_tagging_opt} ;

    # renaming
    if (defined $self->{rename_opt}) {
	my $extension ;
	if ($file_type eq $mp3_type) {
	    $extension = $mp3_ext ;
	} elsif ($file_type eq $ogg_type) {
	    $extension = $ogg_ext ;
	} elsif ($file_type eq $flac_type) {
	    $extension = $flac_ext ;
	}
	Lltag::Rename::rename_with_values ($self, $file, $extension, $new_values) ;
    }

    # next file
  NEXT_FILE:
    shift ;
    next ;

    # exit without tagging anything anymore
  EXIT:
    last ;
}

#############################################
# generate configuration file

sub generate_config {
    my $file = shift ;
    die "Cannot generate $file which already exists."
        if -e "$file" ;
    open NEWCFG, ">$file"
        or die "Cannot open $file ($!).\n" ;

    print NEWCFG "# This is a lltag configuration file.\n" ;
    print NEWCFG "# It was automatically generated.\n" ;
    print NEWCFG "# You may modify and reuse it as you want.\n" ;
    print NEWCFG "\n" ;

    map { print NEWCFG "format = \"$_\"\n" ; } @{$self->{user_format_strings}} ;

    print NEWCFG "guess = $self->{guess_opt}\n" ;
    print NEWCFG "nopath = $self->{nopath_opt}\n" ;

    map { print NEWCFG "default_$_ = \"$self->{field_default}{$_}\"\n" ; } (keys %{$self->{field_default}}) ;

    map { print NEWCFG "tag = \"$_\"\n" ; } @{$self->{additional_tags}} ;

    print NEWCFG "spaces = $self->{spaces_opt}\n" ;
    print NEWCFG "maj = $self->{maj_opt}\n" ;
    print NEWCFG "sep = \"$self->{sep_opt}\"\n"
	if defined $self->{sep_opt} ;
    map { print NEWCFG "regexp = \"$_\"\n" ; } @{$self->{regexp_opts}} ;
    print NEWCFG "type = ". (defined $self->{type_opt} ? $self->{type_opt} : "none") ."\n" ;
    print NEWCFG "clear_tags = $self->{clear_opt}\n" ;
    print NEWCFG "append_tags = $self->{append_opt}\n" ;
    print NEWCFG "no_tagging = $self->{no_tagging_opt}\n" ;

    print NEWCFG "rename_format = \"" .($self->{rename_opt} ? $self->{rename_opt} : ""). "\"\n" ;
    print NEWCFG "rename_min = $self->{rename_min_opt}\n" ;
    print NEWCFG "rename_sep = \"$self->{rename_sep_opt}\"\n" ;
    map { print NEWCFG "rename_regexp = \"$_\"\n" ; } @{$self->{rename_regexp_opts}} ;
    print NEWCFG "rename_ext = $self->{rename_ext_opt}\n" ;

    print NEWCFG "cddb = $self->{cddb_opt}\n" ;
    print NEWCFG "cddb_server_name = \"$self->{cddb_server_name}\"\n" ;
    print NEWCFG "cddb_server_port = $self->{cddb_server_port}\n" ;
    print NEWCFG "cddb_proxy_name = \"$self->{cddb_proxy_name}\"\n" if defined $self->{cddb_proxy_name} ;
    print NEWCFG "cddb_proxy_port = $self->{cddb_proxy_port}\n" if defined $self->{cddb_proxy_name} ;

    print NEWCFG "dry_run = $self->{dry_run_opt}\n" ;
    print NEWCFG "yes = $self->{yes_opt}\n" ;
    print NEWCFG "ask = $self->{ask_opt}\n" ;
    print NEWCFG "recursive = $self->{recursive_opt}\n" ;
    print NEWCFG "verbose = $self->{verbose_opt}\n" ;

    close NEWCFG ;
}

generate_config $self->{gencfg_file}
    if defined $self->{gencfg_file} ;

Lltag::Misc::exit_readline () ;
