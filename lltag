#!/usr/bin/perl -w

use strict ;
no strict "refs" ;

use Getopt::Long ;
Getopt::Long::Configure('noignorecase', 'noautoabbrev', 'bundling') ;

#######################################################
# format parameters
# (%a = artist, %t = title, %A = album, %n = number, %g = genre, %y = year)
my @field_name = ('artist', 'title ', 'album ', 'number', 'genre ', 'year  ') ;
my @field_letter = ('a', 't', 'A', 'n', 'g', 'y') ;
my @field_mp3info_option = ('a', 't', 'l', 'n', 'g', 'y') ;
my @field_vorbiscomment_option = ('ARTIST', 'TITLE', 'ALBUM', 'TRACKNUMBER', 'GENRE', 'DATE') ;
my @field_default = (undef, undef, undef, undef, undef, undef) ;
my $fields = $#field_name + 1 ;

#######################################################
# usage
sub usage() {
    print $0." is a frontend to tag MP3/OGG files automagically.\n" ;
    print "Usage: ".$0." [options] files...\n" ;
    print "   Available options are:\n" ;
    print "     -F, --format <format>  Try format\n" ;
    print "     -G, --guess            Guess format\n" ;
    print "     -p, --nopath           Remove the path from filenames when matching\n" ;
    print map { "     -".$field_letter[$_].", --".$field_name[$_]
		    ." <val>     Set the default value for "
		    .$field_name[$_]."\n" } ( 0 .. $fields-1 ) ;
    print "     --spaces               Allow no or multiple spaces when guessing\n" ;
    print "     --sep <char>           Replace <char> with space in tags\n" ;
    print "     --yes                  Tag without asking for confirmation when guessing\n" ;
    print "     --ask                  Always ask for confirmation before tagging\n" ;
    print "     --mp3/--ogg            Force mp3 or ogg instead of by-extension detection\n" ;
    print "     --dry-run              Do nothing but show what would have been done\n" ;
    print "     -v, --verbose          Verbose messages\n" ;
    print "     -h, --help             Show this help\n" ;
    print "   Format is composed of anything you want with special fields:\n" ;
    print map { "     %".$field_letter[$_]." means ".$field_name[$_]."\n" } ( 0 .. $fields-1 ) ;
    print "     %d means Dummy text\n" ;
    print "     %% means %\n" ;
    print "\n" ;
    print "Author:    Brice Goglin <Brice.Goglin\@ens-lyon.org>\n" ;
    print "Homepage:  http://bgoglin.free.fr/lltag\n" ;
    exit 1;
}

# cmdline options
my $ask_opt = 0 ;
my $dryrun_opt = 0 ;
my $guess_opt = 0 ;
my $nopath_opt = 0 ;
my $sep_opt = undef ;
my $type_opt = undef ;
my $verbose_opt = 0 ;
my $yes_opt = 0 ;

my $ogg_type = "ogg" ;
my $mp3_type = "mp3" ;

# subregexp
my $match_path = '(?:.*\/)*' ;
my $match_any = '((?:[^ ]+ +)*[^ ]+)' ;
my $match_num = '([0-9]+)' ;
my $match_space = ' ';
my $match_spaces = ' *' ;
my $match_limit = '' ;

# the parser that the user wants to always use
my $preferred_parser = undef ;

# parsers
my @format_strings = () ;

# parse options
GetOptions(
	   'F|format=s'   => \@format_strings,
	   'G|guess'      => \$guess_opt,
	   'p|nopath'     => \$nopath_opt,
	   'spaces'       => sub { $match_limit = $match_space = $match_spaces ; },
	   'sep=s'        => \$sep_opt,
	   'yes'          => sub { $yes_opt = 1 ; $ask_opt = 0 ; },
	   'ask'          => sub { $ask_opt = 1 ; $yes_opt = 0 ; },
	   'mp3'          => sub { $type_opt = $mp3_type ; },
	   'ogg'          => sub { $type_opt = $ogg_type ; },
	   'dry-run'      => \$dryrun_opt,
	   'v|verbose'    => \$verbose_opt,
	   'h|help'       => sub { usage () ; },
	   map { $field_letter[$_] => \$field_default[$_] } ( 0 .. $fields-1 )
	   ) or usage () ;

# process remaining command-line arguments as files
die "No files specified\n" if !@ARGV ;

my @files = () ;
while ( @ARGV ) {
    push (@files, shift @ARGV) ;
}

# yes/ask option status may vary with user confirmation replies
my $current_yes_opt = $yes_opt ;
my $current_ask_opt = $ask_opt ;

#######################################################
# change format names into a parsing string
my $field_letters = (join '|', @field_letter).'|d' ;

# change a format strings into usable infos
sub study_format {
    my $format_string = shift ;

    print "Studying format '". $format_string ."'...\n" ;

    my $parser ;
    $parser->{format} = $format_string ;

    # create the regexp and store indice fields
    my @array = split(//, $format_string) ;
    my $j = 0 ;
    for(my $i = 0; $i < @array - 1; $i++) {
	# if that's not a %, keep it
	next unless $array[$i] eq "%" ;
	# remove % and check next char
	splice (@array, $i, 1) ;
	# replace the char with the matching
	my $char = $array[$i] ;
	next if $char eq "%" ;
	if ($array[$i] eq "n") {
	    $array[$i] = $match_num ;
	} elsif ($array[$i] =~ /$field_letters/) {
	    $array[$i] = $match_any ;
	} else {
	    die "  ERROR: Format '". $format_string ."' contains unrecognized operator '%". $array[$i] ."'.\n" ;
	}
	# store the indice
	if ($char eq "d") {
	    $parser->{$j} = -1 ;
	} else {
	    my @indices = grep { $char eq $field_letter[$_] } ( 0 .. $fields-1 ) ;
	    $parser->{$j} = $indices[0] ;
	}
	$j++ ;
    }
    
    # done
    $parser->{regexp} = join("", @array) ;
    $parser->{indices} = $j ;

    # check insolvable regexp
    for(my $i = 0; $i < @array - 1; $i++) {
	my $char = $array[$i] ;
	my $nextchar = $array[$i+1] ;
	if ( $char eq $match_any and
	     ( $nextchar eq $match_any or $nextchar eq $match_num ) ) {
	    print "  WARNING: Format '". $format_string
		."' leads to problematic subregexp '". $char.$nextchar
		."' that won't probably match as desired.\n" ;
	}
    }
    
    if ($verbose_opt) {
	print "  Format string will parse with: ". $parser->{regexp} ."\n" ;
	print "    Fields are: ". (join ';', 
				 map ( $parser->{$_} ."(".
				       ( $parser->{$_} == -1 ? "d" : $field_letter[$parser->{$_}] )
				       .")" , (0..$j-1) )
				 )."\n" ;
    }

    return $parser ;
}

#######################################################
# user parsers

my @parsers = map ( study_format($_), @format_strings ) ;

sub parse_file_with_user_parsers
{
    my $file = shift ;
    my $filename = shift ;
    my $tag_type = shift ;

    # try each format until one works
    foreach my $parser (@parsers) {
	print "  with format '". $parser->{format} ."'... " ;
	if ($filename =~ /^$parser->{regexp}$/) {
	    print "\n" ;
	    # try to tag, without confirmation
	    if (tag_file ($file, $tag_type, $parser, 0, @_)) {
		return 1 ;
	    }
	} else {
	    print "Does not match.\n" ;
	}
    }
    return 0 ;
}

#######################################################
# internal parsers

# internal filename parsers
my @internal_filename_parsers = () ;

my $internal_filename_parser0 ;
$internal_filename_parser0->{format} = "%n - %a - %t" ;
$internal_filename_parser0->{regexp} = $match_limit.$match_num.$match_space."-".$match_space.$match_any.$match_space."-".$match_space.$match_any.$match_limit ;
$internal_filename_parser0->{indices} = 3 ;
$internal_filename_parser0->{0} = 3 ;
$internal_filename_parser0->{1} = 0 ;
$internal_filename_parser0->{2} = 1 ;
push (@internal_filename_parsers, $internal_filename_parser0) ;

my $internal_filename_parser1 ;
$internal_filename_parser1->{format} = "%n - %t" ;
$internal_filename_parser1->{regexp} = $match_limit.$match_num.$match_space."-".$match_space.$match_any.$match_limit ;
$internal_filename_parser1->{indices} = 2 ;
$internal_filename_parser1->{0} = 3 ;
$internal_filename_parser1->{1} = 1 ;
push (@internal_filename_parsers, $internal_filename_parser1) ;

my $internal_filename_parser2 ;
$internal_filename_parser2->{format} = "%n[.)] %t" ;
$internal_filename_parser2->{regexp} = $match_limit.$match_num.'(?:\)|\.)'.$match_space.$match_any.$match_limit ;
$internal_filename_parser2->{indices} = 2 ;
$internal_filename_parser2->{0} = 3 ;
$internal_filename_parser2->{1} = 1 ;
push (@internal_filename_parsers, $internal_filename_parser2) ;

my $internal_filename_parser3 ;
$internal_filename_parser3->{format} = "%a - %n - %t" ;
$internal_filename_parser3->{regexp} = $match_limit.$match_any.$match_space."-".$match_space.$match_num.$match_space."-".$match_space.$match_any.$match_limit ;
$internal_filename_parser3->{indices} = 3 ;
$internal_filename_parser3->{0} = 0 ;
$internal_filename_parser3->{1} = 3 ;
$internal_filename_parser3->{2} = 1 ;
push (@internal_filename_parsers, $internal_filename_parser3) ;

my $internal_filename_parser4 ;
$internal_filename_parser4->{format} = "%a - %t" ;
$internal_filename_parser4->{regexp} = $match_limit.$match_any.$match_space."-".$match_space.$match_any.$match_limit ;
$internal_filename_parser4->{indices} = 2 ;
$internal_filename_parser4->{0} = 0 ;
$internal_filename_parser4->{1} = 1 ;
push (@internal_filename_parsers, $internal_filename_parser4) ;

my $internal_filename_parser5 ;
$internal_filename_parser5->{format} = "%t" ;
$internal_filename_parser5->{regexp} = $match_limit.$match_any.$match_limit ;
$internal_filename_parser5->{indices} = 1 ;
$internal_filename_parser5->{0} = 1 ;
push (@internal_filename_parsers, $internal_filename_parser5) ;

# internal path parsers
my @internal_path_parsers = () ;

my $internal_path_parser0 ;
$internal_path_parser0->{format} = "%a/%a - %A" ;
$internal_path_parser0->{regexp} = $match_path.$match_limit.$match_any.$match_limit."/".$match_limit.$match_any.$match_space."-".$match_space.$match_any.$match_limit ;
$internal_path_parser0->{indices} = 3 ;
$internal_path_parser0->{0} = 0 ;
$internal_path_parser0->{1} = 0 ;
$internal_path_parser0->{2} = 2 ;
push (@internal_path_parsers, $internal_path_parser0) ;

my $internal_path_parser1 ;
$internal_path_parser1->{format} = "%a/%A" ;
$internal_path_parser1->{regexp} = $match_path.$match_limit.$match_any.$match_limit."/".$match_limit.$match_any.$match_limit ;
$internal_path_parser1->{indices} = 2 ;
$internal_path_parser1->{0} = 0 ;
$internal_path_parser1->{1} = 2 ;
push (@internal_path_parsers, $internal_path_parser1) ;

my $internal_path_parser2 ;
$internal_path_parser2->{format} = "%a" ;
$internal_path_parser2->{regexp} = $match_path.$match_limit.$match_any.$match_limit ;
$internal_path_parser2->{indices} = 1 ;
$internal_path_parser2->{0} = 0 ;
push (@internal_path_parsers, $internal_path_parser2) ;

my $internal_path_parser3 ;
$internal_path_parser3->{format} = "%A" ;
$internal_path_parser3->{regexp} = $match_path.$match_limit.$match_any.$match_limit ;
$internal_path_parser3->{indices} = 1 ;
$internal_path_parser3->{0} = 2 ;
push (@internal_path_parsers, $internal_path_parser3) ;

# merge path and filename internal parsers
sub merge_internal_parsers
{
    my $path_parser = shift ;
    my $filename_parser = shift ;
    my $parser ;
    $parser->{format} = "$path_parser->{format}/$filename_parser->{format}" ;
    $parser->{regexp} = "$path_parser->{regexp}/$filename_parser->{regexp}" ;
    $parser->{indices} = $path_parser->{indices} + $filename_parser->{indices} ;
    for(my $i=0; $i < $path_parser->{indices}; $i++) {
	$parser->{$i} = $path_parser->{$i} ;
    }
    for(my $i=0; $i < $filename_parser->{indices}; $i++) {
	$parser->{$i+$path_parser->{indices}} = $filename_parser->{$i} ;
    }
    return $parser ;
}

# parse
sub parse_file_with_internal_parsers
{
    my $file = shift ;
    my $filename = shift ;
    my $tag_type = shift ;

    print "  with internal formats...\n" ;

    # split into path and parts if possible
    my @parts = split (/\//, $filename) ;
    $filename = pop @parts ;

    if (!$nopath_opt and @parts) {
	# try each path parser and each filename parser
	my $path = join ("/", @parts) ;
	foreach my $path_parser (@internal_path_parsers) {
	    if ($path =~ /^$path_parser->{regexp}$/) {
		foreach my $filename_parser (@internal_filename_parsers) {
		    # match the whole path+filename to get a clean @_ for tag_file
		    if ("$path/$filename" =~ /^$path_parser->{regexp}\/$filename_parser->{regexp}$/) {
			print "    '$path_parser->{format}/$filename_parser->{format}' matches this file\n" ;
			my $whole_parser = merge_internal_parsers ($path_parser, $filename_parser) ;
			# try to tag, with confirmation
			if (tag_file ($file, $tag_type, $whole_parser, 1, @_)) {
			    return 1 ;
			}
		    }
		}
	    }
	}
    } else {
	# no path, only try each filename parser
	foreach my $filename_parser (@internal_filename_parsers) {
	    if ($filename =~ /^$filename_parser->{regexp}$/) {
		print "    '$filename_parser->{format}' matches this file\n" ;
		# try to tag, with confirmation
		if (tag_file ($file, $tag_type, $filename_parser, 1, @_)) {
		    return 1 ;
		}
	    }
	}
    }
    return 0 ;
}

#######################################################
# if no parsers and no guess
die "No format to try\n" unless @parsers or $guess_opt;
# TOFIX: afficher ? option pour afficher

#######################################################
# process files

while ( @files ) {
    my $file = shift @files ;

    print "Processing file \"".$file."\"...\n" ;

    # removing path if asked, only in $filename, keep $file complete
    my $filename = $file ;
    if ($nopath_opt && $filename =~ /\//) {
	$filename =~ s/.*\/([^\/]+)/$1/ ;
    }
    
    # split into filename and extension
    my @parts = split (/\./, $filename) ;
    my $extension = pop @parts ;
    $filename = join (".", @parts) ;
    
    # split into filename and extension
    my $tag_type = $type_opt ;
    if (not defined $tag_type) {
	if ($extension eq "ogg") {
	    $tag_type = $ogg_type ;
	} elsif ($extension eq "mp3") {
	    $tag_type = $mp3_type ;
	} else {
	    print "  Skipping this unknown-type file '$file'\n" ;
	    goto NEXT_FILE ;
	}
    }

    if (defined $preferred_parser) {
	if ($filename =~ /^$preferred_parser->{regexp}$/) {
	    if (tag_file ($file, $tag_type, $preferred_parser, 0, @_)) {
		goto NEXT_FILE ;
	    }
	} else {
	    print "  Preferred parser '$preferred_parser->{format}' does not match this file\n" ;
	    print "    Returning to original mode\n" ;
	    $current_ask_opt = $ask_opt ; $current_yes_opt = $yes_opt ;
	}
	$preferred_parser = undef ;
    }

    if (parse_file_with_user_parsers($file, $filename, $tag_type)) {
	goto NEXT_FILE ;
    }

    if ($guess_opt) {
	if (parse_file_with_internal_parsers($file, $filename, $tag_type)) {
	    goto NEXT_FILE ;
	}
    }

    print "  Didn't find any parser!\n" ;
    #TOFIX: ask each field ?

  NEXT_FILE:
    shift ;
}

#######################################################
# really tag files

sub confirm_usage {
    print "        y => Yes, tag with this format\n" ;
    print "        n => No, try the next matching format\n" ;
    print "        a => Always yes, stop asking for a confirmation\n" ;
    print "        u => Use this format for all remaining matching files\n" ;
    print "        s => Skip this file, don't tag it\n" ;
    print "        h => Show this help\n" ;
}

sub tag_file {
    my $file = shift ;
    my $tag_type = shift ;
    my $parser = shift ;
    my $confirm = shift ;

    my @field = @field_default ;
    $#field = $fields ;

    # get fields and show them if asked
    my $i = 1 ;
    while ( $i <= $parser->{indices} ) {
	if ( $parser->{$i-1} >= 0 ) {
	    my $val = ${$i} ;
	    if (defined $sep_opt) {
		$val =~ s/$sep_opt/ /g ;
	    }
	    $field[$parser->{$i-1}] = $val ;		
	    if ($verbose_opt or $confirm or $current_ask_opt) {
		print "      ". ucfirst($field_name[$parser->{$i-1}])
		    .": ". $val ."\n" ;
	    }
	}
	$i++ ;
    }

    # confirm if required
    if ($current_ask_opt or ($confirm and !$current_yes_opt)) {
      ASK_CONFIRM:
	print "      Really tag the file [ynaus,(H)elp] ? " ;
	my $reply = <> ;
	if ($reply =~ /^y/i) {
	    goto TAG_IT ;
	} elsif ($reply =~ /^a/i) {
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto TAG_IT ;
	} elsif ($reply =~ /^u/i) {
	    $preferred_parser = $parser ;
	    $current_ask_opt = 0 ; $current_yes_opt = 1 ;
	    goto TAG_IT ;
	} elsif ($reply =~ /^n/i) {
	    return 0 ;
	} elsif ($reply =~ /^s/i) {
	    return -1 ;
	} else {
	    confirm_usage () ;
	    goto ASK_CONFIRM ;
	}
    }
    
  TAG_IT:
    # tagging command line
    my @system_args ;
    if ($tag_type eq $ogg_type) {
	@system_args =
	    ( "vorbiscomment", "-wq",
	      ( map { ( "-t" , $field_vorbiscomment_option[$_]."=".$field[$_] ) }
		( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
		) ,
	      $file
	      ) ;
    } elsif ($tag_type eq $mp3_type) {
	@system_args =
	    ( "mp3info" ,
	      ( map { ( "-".$field_mp3info_option[$_] , $field[$_] ) }
		( grep { defined $field[$_] } ( 0 .. $fields-1 ) )
		) ,
	      $file
	      ) ;
	    }
    
    # show command line and really tag if asked
    if ($dryrun_opt or $verbose_opt) {
	print "      ". +(join '# #', @system_args) ."\n" ;
	}
    if (!$dryrun_opt) {
	print "      Tagging.\n" ;
	system @system_args ;
    }

    return 1 ;
}    
